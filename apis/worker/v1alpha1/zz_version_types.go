// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
	v1apiextensions "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
)

type AnnotationsInitParameters struct {

	// Human-readable message about the version.
	WorkersMessage *string `json:"workersMessage,omitempty" tf:"workers_message,omitempty"`

	// User-provided identifier for the version.
	WorkersTag *string `json:"workersTag,omitempty" tf:"workers_tag,omitempty"`
}

type AnnotationsObservation struct {

	// Human-readable message about the version.
	WorkersMessage *string `json:"workersMessage,omitempty" tf:"workers_message,omitempty"`

	// User-provided identifier for the version.
	WorkersTag *string `json:"workersTag,omitempty" tf:"workers_tag,omitempty"`

	// Operation that triggered the creation of the version.
	WorkersTriggeredBy *string `json:"workersTriggeredBy,omitempty" tf:"workers_triggered_by,omitempty"`
}

type AnnotationsParameters struct {

	// Human-readable message about the version.
	// +kubebuilder:validation:Optional
	WorkersMessage *string `json:"workersMessage,omitempty" tf:"workers_message,omitempty"`

	// User-provided identifier for the version.
	// +kubebuilder:validation:Optional
	WorkersTag *string `json:"workersTag,omitempty" tf:"workers_tag,omitempty"`
}

type AssetsInitParameters struct {
	Config *ConfigInitParameters `json:"config,omitempty" tf:"config,omitempty"`

	// Path to the directory containing asset files to upload.
	Directory *string `json:"directory,omitempty" tf:"directory,omitempty"`

	// Token provided upon successful upload of all files from a registered manifest.
	JwtSecretRef *v1.SecretKeySelector `json:"jwtSecretRef,omitempty" tf:"-"`
}

type AssetsObservation struct {

	// The SHA-256 hash of the asset manifest of files to upload.
	AssetManifestSha256 *string `json:"assetManifestSha256,omitempty" tf:"asset_manifest_sha256,omitempty"`

	Config *ConfigObservation `json:"config,omitempty" tf:"config,omitempty"`

	// Path to the directory containing asset files to upload.
	Directory *string `json:"directory,omitempty" tf:"directory,omitempty"`
}

type AssetsParameters struct {

	// +kubebuilder:validation:Optional
	Config *ConfigParameters `json:"config,omitempty" tf:"config,omitempty"`

	// Path to the directory containing asset files to upload.
	// +kubebuilder:validation:Optional
	Directory *string `json:"directory,omitempty" tf:"directory,omitempty"`

	// Token provided upon successful upload of all files from a registered manifest.
	// +kubebuilder:validation:Optional
	JwtSecretRef *v1.SecretKeySelector `json:"jwtSecretRef,omitempty" tf:"-"`
}

type BindingsInitParameters struct {

	// Algorithm-specific key parameters. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#algorithm).
	Algorithm *string `json:"algorithm,omitempty" tf:"algorithm,omitempty"`

	// List of allowed destination addresses.
	AllowedDestinationAddresses []*string `json:"allowedDestinationAddresses,omitempty" tf:"allowed_destination_addresses,omitempty"`

	// List of allowed sender addresses.
	AllowedSenderAddresses []*string `json:"allowedSenderAddresses,omitempty" tf:"allowed_sender_addresses,omitempty"`

	// R2 bucket to bind to.
	BucketName *string `json:"bucketName,omitempty" tf:"bucket_name,omitempty"`

	// Identifier of the certificate to bind to.
	CertificateID *string `json:"certificateId,omitempty" tf:"certificate_id,omitempty"`

	// The exported class name of the Durable Object.
	ClassName *string `json:"className,omitempty" tf:"class_name,omitempty"`

	// The name of the dataset to bind to.
	Dataset *string `json:"dataset,omitempty" tf:"dataset,omitempty"`

	// Destination address for the email.
	DestinationAddress *string `json:"destinationAddress,omitempty" tf:"destination_address,omitempty"`

	// The environment of the script_name to bind to.
	Environment *string `json:"environment,omitempty" tf:"environment,omitempty"`

	// Data format of the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#format).
	// Available values: "raw", "pkcs8", "spki", "jwk".
	Format *string `json:"format,omitempty" tf:"format,omitempty"`

	// Identifier of the D1 database to bind to.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Name of the Vectorize index to bind to.
	IndexName *string `json:"indexName,omitempty" tf:"index_name,omitempty"`

	// JSON data to use.
	JSON *string `json:"json,omitempty" tf:"json,omitempty"`

	// The [jurisdiction](https://developers.cloudflare.com/r2/reference/data-location/#jurisdictional-restrictions) of the R2 bucket.
	// Available values: "eu", "fedramp".
	Jurisdiction *string `json:"jurisdiction,omitempty" tf:"jurisdiction,omitempty"`

	// Base64-encoded key data. Required if `format` is "raw", "pkcs8", or "spki".
	KeyBase64SecretRef *v1.SecretKeySelector `json:"keyBase64SecretRef,omitempty" tf:"-"`

	// Key data in [JSON Web Key](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#json_web_key) format. Required if `format` is "jwk".
	KeyJwkSecretRef *v1.SecretKeySelector `json:"keyJwkSecretRef,omitempty" tf:"-"`

	// A JavaScript variable name for the binding.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The name of the dispatch namespace.
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// Namespace identifier tag.
	NamespaceID *string `json:"namespaceId,omitempty" tf:"namespace_id,omitempty"`

	// The old name of the inherited binding. If set, the binding will be renamed from `old_name` to `name` in the new version. If not set, the binding will keep the same name between versions.
	OldName *string `json:"oldName,omitempty" tf:"old_name,omitempty"`

	Outbound *OutboundInitParameters `json:"outbound,omitempty" tf:"outbound,omitempty"`

	// The name of the file containing the data content. Only accepted for `service worker syntax` Workers.
	Part *string `json:"part,omitempty" tf:"part,omitempty"`

	// Name of the Pipeline to bind to.
	Pipeline *string `json:"pipeline,omitempty" tf:"pipeline,omitempty"`

	// Name of the Queue to bind to.
	QueueName *string `json:"queueName,omitempty" tf:"queue_name,omitempty"`

	// The script where the Durable Object is defined, if it is external to this Worker.
	ScriptName *string `json:"scriptName,omitempty" tf:"script_name,omitempty"`

	// Name of the secret in the store.
	SecretName *string `json:"secretName,omitempty" tf:"secret_name,omitempty"`

	// Name of Worker to bind to.
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// ID of the store containing the secret.
	StoreID *string `json:"storeId,omitempty" tf:"store_id,omitempty"`

	// The text value to use.
	TextSecretRef *v1.SecretKeySelector `json:"textSecretRef,omitempty" tf:"-"`

	// The kind of resource that the binding provides.
	// Available values: "ai", "analytics_engine", "assets", "browser", "d1", "data_blob", "dispatch_namespace", "durable_object_namespace", "hyperdrive", "inherit", "images", "json", "kv_namespace", "mtls_certificate", "plain_text", "pipelines", "queue", "r2_bucket", "secret_text", "send_email", "service", "text_blob", "vectorize", "version_metadata", "secrets_store_secret", "secret_key", "workflow", "wasm_module".
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Allowed operations with the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#keyUsages).
	// +listType=set
	Usages []*string `json:"usages,omitempty" tf:"usages,omitempty"`

	// Identifier for the version to inherit the binding from, which can be the version ID or the literal "latest" to inherit from the latest version. Defaults to inheriting the binding from the latest version.
	VersionID *string `json:"versionId,omitempty" tf:"version_id,omitempty"`

	// Name of the Workflow to bind to.
	WorkflowName *string `json:"workflowName,omitempty" tf:"workflow_name,omitempty"`
}

type BindingsObservation struct {

	// Algorithm-specific key parameters. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#algorithm).
	Algorithm *string `json:"algorithm,omitempty" tf:"algorithm,omitempty"`

	// List of allowed destination addresses.
	AllowedDestinationAddresses []*string `json:"allowedDestinationAddresses,omitempty" tf:"allowed_destination_addresses,omitempty"`

	// List of allowed sender addresses.
	AllowedSenderAddresses []*string `json:"allowedSenderAddresses,omitempty" tf:"allowed_sender_addresses,omitempty"`

	// R2 bucket to bind to.
	BucketName *string `json:"bucketName,omitempty" tf:"bucket_name,omitempty"`

	// Identifier of the certificate to bind to.
	CertificateID *string `json:"certificateId,omitempty" tf:"certificate_id,omitempty"`

	// The exported class name of the Durable Object.
	ClassName *string `json:"className,omitempty" tf:"class_name,omitempty"`

	// The name of the dataset to bind to.
	Dataset *string `json:"dataset,omitempty" tf:"dataset,omitempty"`

	// Destination address for the email.
	DestinationAddress *string `json:"destinationAddress,omitempty" tf:"destination_address,omitempty"`

	// The environment of the script_name to bind to.
	Environment *string `json:"environment,omitempty" tf:"environment,omitempty"`

	// Data format of the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#format).
	// Available values: "raw", "pkcs8", "spki", "jwk".
	Format *string `json:"format,omitempty" tf:"format,omitempty"`

	// Identifier of the D1 database to bind to.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Name of the Vectorize index to bind to.
	IndexName *string `json:"indexName,omitempty" tf:"index_name,omitempty"`

	// JSON data to use.
	JSON *string `json:"json,omitempty" tf:"json,omitempty"`

	// The [jurisdiction](https://developers.cloudflare.com/r2/reference/data-location/#jurisdictional-restrictions) of the R2 bucket.
	// Available values: "eu", "fedramp".
	Jurisdiction *string `json:"jurisdiction,omitempty" tf:"jurisdiction,omitempty"`

	// A JavaScript variable name for the binding.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The name of the dispatch namespace.
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// Namespace identifier tag.
	NamespaceID *string `json:"namespaceId,omitempty" tf:"namespace_id,omitempty"`

	// The old name of the inherited binding. If set, the binding will be renamed from `old_name` to `name` in the new version. If not set, the binding will keep the same name between versions.
	OldName *string `json:"oldName,omitempty" tf:"old_name,omitempty"`

	Outbound *OutboundObservation `json:"outbound,omitempty" tf:"outbound,omitempty"`

	// The name of the file containing the data content. Only accepted for `service worker syntax` Workers.
	Part *string `json:"part,omitempty" tf:"part,omitempty"`

	// Name of the Pipeline to bind to.
	Pipeline *string `json:"pipeline,omitempty" tf:"pipeline,omitempty"`

	// Name of the Queue to bind to.
	QueueName *string `json:"queueName,omitempty" tf:"queue_name,omitempty"`

	// The script where the Durable Object is defined, if it is external to this Worker.
	ScriptName *string `json:"scriptName,omitempty" tf:"script_name,omitempty"`

	// Name of the secret in the store.
	SecretName *string `json:"secretName,omitempty" tf:"secret_name,omitempty"`

	// Name of Worker to bind to.
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// ID of the store containing the secret.
	StoreID *string `json:"storeId,omitempty" tf:"store_id,omitempty"`

	// The kind of resource that the binding provides.
	// Available values: "ai", "analytics_engine", "assets", "browser", "d1", "data_blob", "dispatch_namespace", "durable_object_namespace", "hyperdrive", "inherit", "images", "json", "kv_namespace", "mtls_certificate", "plain_text", "pipelines", "queue", "r2_bucket", "secret_text", "send_email", "service", "text_blob", "vectorize", "version_metadata", "secrets_store_secret", "secret_key", "workflow", "wasm_module".
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Allowed operations with the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#keyUsages).
	// +listType=set
	Usages []*string `json:"usages,omitempty" tf:"usages,omitempty"`

	// Identifier for the version to inherit the binding from, which can be the version ID or the literal "latest" to inherit from the latest version. Defaults to inheriting the binding from the latest version.
	VersionID *string `json:"versionId,omitempty" tf:"version_id,omitempty"`

	// Name of the Workflow to bind to.
	WorkflowName *string `json:"workflowName,omitempty" tf:"workflow_name,omitempty"`
}

type BindingsParameters struct {

	// Algorithm-specific key parameters. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#algorithm).
	// +kubebuilder:validation:Optional
	Algorithm *string `json:"algorithm,omitempty" tf:"algorithm,omitempty"`

	// List of allowed destination addresses.
	// +kubebuilder:validation:Optional
	AllowedDestinationAddresses []*string `json:"allowedDestinationAddresses,omitempty" tf:"allowed_destination_addresses,omitempty"`

	// List of allowed sender addresses.
	// +kubebuilder:validation:Optional
	AllowedSenderAddresses []*string `json:"allowedSenderAddresses,omitempty" tf:"allowed_sender_addresses,omitempty"`

	// R2 bucket to bind to.
	// +kubebuilder:validation:Optional
	BucketName *string `json:"bucketName,omitempty" tf:"bucket_name,omitempty"`

	// Identifier of the certificate to bind to.
	// +kubebuilder:validation:Optional
	CertificateID *string `json:"certificateId,omitempty" tf:"certificate_id,omitempty"`

	// The exported class name of the Durable Object.
	// +kubebuilder:validation:Optional
	ClassName *string `json:"className,omitempty" tf:"class_name,omitempty"`

	// The name of the dataset to bind to.
	// +kubebuilder:validation:Optional
	Dataset *string `json:"dataset,omitempty" tf:"dataset,omitempty"`

	// Destination address for the email.
	// +kubebuilder:validation:Optional
	DestinationAddress *string `json:"destinationAddress,omitempty" tf:"destination_address,omitempty"`

	// The environment of the script_name to bind to.
	// +kubebuilder:validation:Optional
	Environment *string `json:"environment,omitempty" tf:"environment,omitempty"`

	// Data format of the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#format).
	// Available values: "raw", "pkcs8", "spki", "jwk".
	// +kubebuilder:validation:Optional
	Format *string `json:"format,omitempty" tf:"format,omitempty"`

	// Identifier of the D1 database to bind to.
	// +kubebuilder:validation:Optional
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Name of the Vectorize index to bind to.
	// +kubebuilder:validation:Optional
	IndexName *string `json:"indexName,omitempty" tf:"index_name,omitempty"`

	// JSON data to use.
	// +kubebuilder:validation:Optional
	JSON *string `json:"json,omitempty" tf:"json,omitempty"`

	// The [jurisdiction](https://developers.cloudflare.com/r2/reference/data-location/#jurisdictional-restrictions) of the R2 bucket.
	// Available values: "eu", "fedramp".
	// +kubebuilder:validation:Optional
	Jurisdiction *string `json:"jurisdiction,omitempty" tf:"jurisdiction,omitempty"`

	// Base64-encoded key data. Required if `format` is "raw", "pkcs8", or "spki".
	// +kubebuilder:validation:Optional
	KeyBase64SecretRef *v1.SecretKeySelector `json:"keyBase64SecretRef,omitempty" tf:"-"`

	// Key data in [JSON Web Key](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#json_web_key) format. Required if `format` is "jwk".
	// +kubebuilder:validation:Optional
	KeyJwkSecretRef *v1.SecretKeySelector `json:"keyJwkSecretRef,omitempty" tf:"-"`

	// A JavaScript variable name for the binding.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// The name of the dispatch namespace.
	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// Namespace identifier tag.
	// +kubebuilder:validation:Optional
	NamespaceID *string `json:"namespaceId,omitempty" tf:"namespace_id,omitempty"`

	// The old name of the inherited binding. If set, the binding will be renamed from `old_name` to `name` in the new version. If not set, the binding will keep the same name between versions.
	// +kubebuilder:validation:Optional
	OldName *string `json:"oldName,omitempty" tf:"old_name,omitempty"`

	// +kubebuilder:validation:Optional
	Outbound *OutboundParameters `json:"outbound,omitempty" tf:"outbound,omitempty"`

	// The name of the file containing the data content. Only accepted for `service worker syntax` Workers.
	// +kubebuilder:validation:Optional
	Part *string `json:"part,omitempty" tf:"part,omitempty"`

	// Name of the Pipeline to bind to.
	// +kubebuilder:validation:Optional
	Pipeline *string `json:"pipeline,omitempty" tf:"pipeline,omitempty"`

	// Name of the Queue to bind to.
	// +kubebuilder:validation:Optional
	QueueName *string `json:"queueName,omitempty" tf:"queue_name,omitempty"`

	// The script where the Durable Object is defined, if it is external to this Worker.
	// +kubebuilder:validation:Optional
	ScriptName *string `json:"scriptName,omitempty" tf:"script_name,omitempty"`

	// Name of the secret in the store.
	// +kubebuilder:validation:Optional
	SecretName *string `json:"secretName,omitempty" tf:"secret_name,omitempty"`

	// Name of Worker to bind to.
	// +kubebuilder:validation:Optional
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// ID of the store containing the secret.
	// +kubebuilder:validation:Optional
	StoreID *string `json:"storeId,omitempty" tf:"store_id,omitempty"`

	// The text value to use.
	// +kubebuilder:validation:Optional
	TextSecretRef *v1.SecretKeySelector `json:"textSecretRef,omitempty" tf:"-"`

	// The kind of resource that the binding provides.
	// Available values: "ai", "analytics_engine", "assets", "browser", "d1", "data_blob", "dispatch_namespace", "durable_object_namespace", "hyperdrive", "inherit", "images", "json", "kv_namespace", "mtls_certificate", "plain_text", "pipelines", "queue", "r2_bucket", "secret_text", "send_email", "service", "text_blob", "vectorize", "version_metadata", "secrets_store_secret", "secret_key", "workflow", "wasm_module".
	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`

	// Allowed operations with the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#keyUsages).
	// +kubebuilder:validation:Optional
	// +listType=set
	Usages []*string `json:"usages,omitempty" tf:"usages,omitempty"`

	// Identifier for the version to inherit the binding from, which can be the version ID or the literal "latest" to inherit from the latest version. Defaults to inheriting the binding from the latest version.
	// +kubebuilder:validation:Optional
	VersionID *string `json:"versionId,omitempty" tf:"version_id,omitempty"`

	// Name of the Workflow to bind to.
	// +kubebuilder:validation:Optional
	WorkflowName *string `json:"workflowName,omitempty" tf:"workflow_name,omitempty"`
}

type ConfigInitParameters struct {

	// Determines the redirects and rewrites of requests for HTML content.
	// Available values: "auto-trailing-slash", "force-trailing-slash", "drop-trailing-slash", "none".
	HTMLHandling *string `json:"htmlHandling,omitempty" tf:"html_handling,omitempty"`

	// Determines the response when a request does not match a static asset, and there is no Worker script.
	// Available values: "none", "404-page", "single-page-application".
	NotFoundHandling *string `json:"notFoundHandling,omitempty" tf:"not_found_handling,omitempty"`

	// When a boolean true, requests will always invoke the Worker script. Otherwise, attempt to serve an asset matching the request, falling back to the Worker script. When a list of strings, contains path rules to control routing to either the Worker or assets. Glob (*) and negative (!) rules are supported. Rules must start with either '/' or '!/'. At least one non-negative rule must be provided, and negative rules have higher precedence than non-negative rules.
	RunWorkerFirst *v1apiextensions.JSON `json:"runWorkerFirst,omitempty" tf:"run_worker_first,omitempty"`
}

type ConfigObservation struct {

	// Determines the redirects and rewrites of requests for HTML content.
	// Available values: "auto-trailing-slash", "force-trailing-slash", "drop-trailing-slash", "none".
	HTMLHandling *string `json:"htmlHandling,omitempty" tf:"html_handling,omitempty"`

	// Determines the response when a request does not match a static asset, and there is no Worker script.
	// Available values: "none", "404-page", "single-page-application".
	NotFoundHandling *string `json:"notFoundHandling,omitempty" tf:"not_found_handling,omitempty"`

	// When a boolean true, requests will always invoke the Worker script. Otherwise, attempt to serve an asset matching the request, falling back to the Worker script. When a list of strings, contains path rules to control routing to either the Worker or assets. Glob (*) and negative (!) rules are supported. Rules must start with either '/' or '!/'. At least one non-negative rule must be provided, and negative rules have higher precedence than non-negative rules.
	RunWorkerFirst *v1apiextensions.JSON `json:"runWorkerFirst,omitempty" tf:"run_worker_first,omitempty"`
}

type ConfigParameters struct {

	// Determines the redirects and rewrites of requests for HTML content.
	// Available values: "auto-trailing-slash", "force-trailing-slash", "drop-trailing-slash", "none".
	// +kubebuilder:validation:Optional
	HTMLHandling *string `json:"htmlHandling,omitempty" tf:"html_handling,omitempty"`

	// Determines the response when a request does not match a static asset, and there is no Worker script.
	// Available values: "none", "404-page", "single-page-application".
	// +kubebuilder:validation:Optional
	NotFoundHandling *string `json:"notFoundHandling,omitempty" tf:"not_found_handling,omitempty"`

	// When a boolean true, requests will always invoke the Worker script. Otherwise, attempt to serve an asset matching the request, falling back to the Worker script. When a list of strings, contains path rules to control routing to either the Worker or assets. Glob (*) and negative (!) rules are supported. Rules must start with either '/' or '!/'. At least one non-negative rule must be provided, and negative rules have higher precedence than non-negative rules.
	// +kubebuilder:validation:Optional
	RunWorkerFirst *v1apiextensions.JSON `json:"runWorkerFirst,omitempty" tf:"run_worker_first,omitempty"`
}

type LimitsInitParameters struct {

	// CPU time limit in milliseconds.
	CPUMs *float64 `json:"cpuMs,omitempty" tf:"cpu_ms,omitempty"`
}

type LimitsObservation struct {

	// CPU time limit in milliseconds.
	CPUMs *float64 `json:"cpuMs,omitempty" tf:"cpu_ms,omitempty"`
}

type LimitsParameters struct {

	// CPU time limit in milliseconds.
	// +kubebuilder:validation:Optional
	CPUMs *float64 `json:"cpuMs" tf:"cpu_ms,omitempty"`
}

type MigrationsInitParameters struct {

	// A list of classes to delete Durable Object namespaces from.
	DeletedClasses []*string `json:"deletedClasses,omitempty" tf:"deleted_classes,omitempty"`

	// A list of classes to create Durable Object namespaces from.
	NewClasses []*string `json:"newClasses,omitempty" tf:"new_classes,omitempty"`

	// A list of classes to create Durable Object namespaces with SQLite from.
	NewSqliteClasses []*string `json:"newSqliteClasses,omitempty" tf:"new_sqlite_classes,omitempty"`

	// Tag to set as the latest migration tag.
	NewTag *string `json:"newTag,omitempty" tf:"new_tag,omitempty"`

	// Tag used to verify against the latest migration tag for this Worker. If they don't match, the upload is rejected.
	OldTag *string `json:"oldTag,omitempty" tf:"old_tag,omitempty"`

	RenamedClasses []RenamedClassesInitParameters `json:"renamedClasses,omitempty" tf:"renamed_classes,omitempty"`

	Steps []StepsInitParameters `json:"steps,omitempty" tf:"steps,omitempty"`

	TransferredClasses []MigrationsTransferredClassesInitParameters `json:"transferredClasses,omitempty" tf:"transferred_classes,omitempty"`
}

type MigrationsObservation struct {

	// A list of classes to delete Durable Object namespaces from.
	DeletedClasses []*string `json:"deletedClasses,omitempty" tf:"deleted_classes,omitempty"`

	// A list of classes to create Durable Object namespaces from.
	NewClasses []*string `json:"newClasses,omitempty" tf:"new_classes,omitempty"`

	// A list of classes to create Durable Object namespaces with SQLite from.
	NewSqliteClasses []*string `json:"newSqliteClasses,omitempty" tf:"new_sqlite_classes,omitempty"`

	// Tag to set as the latest migration tag.
	NewTag *string `json:"newTag,omitempty" tf:"new_tag,omitempty"`

	// Tag used to verify against the latest migration tag for this Worker. If they don't match, the upload is rejected.
	OldTag *string `json:"oldTag,omitempty" tf:"old_tag,omitempty"`

	RenamedClasses []RenamedClassesObservation `json:"renamedClasses,omitempty" tf:"renamed_classes,omitempty"`

	Steps []StepsObservation `json:"steps,omitempty" tf:"steps,omitempty"`

	TransferredClasses []MigrationsTransferredClassesObservation `json:"transferredClasses,omitempty" tf:"transferred_classes,omitempty"`
}

type MigrationsParameters struct {

	// A list of classes to delete Durable Object namespaces from.
	// +kubebuilder:validation:Optional
	DeletedClasses []*string `json:"deletedClasses,omitempty" tf:"deleted_classes,omitempty"`

	// A list of classes to create Durable Object namespaces from.
	// +kubebuilder:validation:Optional
	NewClasses []*string `json:"newClasses,omitempty" tf:"new_classes,omitempty"`

	// A list of classes to create Durable Object namespaces with SQLite from.
	// +kubebuilder:validation:Optional
	NewSqliteClasses []*string `json:"newSqliteClasses,omitempty" tf:"new_sqlite_classes,omitempty"`

	// Tag to set as the latest migration tag.
	// +kubebuilder:validation:Optional
	NewTag *string `json:"newTag,omitempty" tf:"new_tag,omitempty"`

	// Tag used to verify against the latest migration tag for this Worker. If they don't match, the upload is rejected.
	// +kubebuilder:validation:Optional
	OldTag *string `json:"oldTag,omitempty" tf:"old_tag,omitempty"`

	// +kubebuilder:validation:Optional
	RenamedClasses []RenamedClassesParameters `json:"renamedClasses,omitempty" tf:"renamed_classes,omitempty"`

	// +kubebuilder:validation:Optional
	Steps []StepsParameters `json:"steps,omitempty" tf:"steps,omitempty"`

	// +kubebuilder:validation:Optional
	TransferredClasses []MigrationsTransferredClassesParameters `json:"transferredClasses,omitempty" tf:"transferred_classes,omitempty"`
}

type MigrationsTransferredClassesInitParameters struct {
	From *string `json:"from,omitempty" tf:"from,omitempty"`

	FromScript *string `json:"fromScript,omitempty" tf:"from_script,omitempty"`

	To *string `json:"to,omitempty" tf:"to,omitempty"`
}

type MigrationsTransferredClassesObservation struct {
	From *string `json:"from,omitempty" tf:"from,omitempty"`

	FromScript *string `json:"fromScript,omitempty" tf:"from_script,omitempty"`

	To *string `json:"to,omitempty" tf:"to,omitempty"`
}

type MigrationsTransferredClassesParameters struct {

	// +kubebuilder:validation:Optional
	From *string `json:"from,omitempty" tf:"from,omitempty"`

	// +kubebuilder:validation:Optional
	FromScript *string `json:"fromScript,omitempty" tf:"from_script,omitempty"`

	// +kubebuilder:validation:Optional
	To *string `json:"to,omitempty" tf:"to,omitempty"`
}

type ModulesInitParameters struct {

	// The base64-encoded module content.
	ContentBase64 *string `json:"contentBase64,omitempty" tf:"content_base64,omitempty"`

	// The file path of the module content.
	ContentFile *string `json:"contentFile,omitempty" tf:"content_file,omitempty"`

	// The content type of the module.
	ContentType *string `json:"contentType,omitempty" tf:"content_type,omitempty"`

	// The name of the module.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type ModulesObservation struct {

	// The base64-encoded module content.
	ContentBase64 *string `json:"contentBase64,omitempty" tf:"content_base64,omitempty"`

	// The file path of the module content.
	ContentFile *string `json:"contentFile,omitempty" tf:"content_file,omitempty"`

	// The SHA-256 hash of the module content.
	ContentSha256 *string `json:"contentSha256,omitempty" tf:"content_sha256,omitempty"`

	// The content type of the module.
	ContentType *string `json:"contentType,omitempty" tf:"content_type,omitempty"`

	// The name of the module.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type ModulesParameters struct {

	// The base64-encoded module content.
	// +kubebuilder:validation:Optional
	ContentBase64 *string `json:"contentBase64,omitempty" tf:"content_base64,omitempty"`

	// The file path of the module content.
	// +kubebuilder:validation:Optional
	ContentFile *string `json:"contentFile,omitempty" tf:"content_file,omitempty"`

	// The content type of the module.
	// +kubebuilder:validation:Optional
	ContentType *string `json:"contentType" tf:"content_type,omitempty"`

	// The name of the module.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`
}

type OutboundInitParameters struct {

	// Pass information from the Dispatch Worker to the Outbound Worker through the parameters.
	Params []*string `json:"params,omitempty" tf:"params,omitempty"`

	Worker *WorkerInitParameters `json:"worker,omitempty" tf:"worker,omitempty"`
}

type OutboundObservation struct {

	// Pass information from the Dispatch Worker to the Outbound Worker through the parameters.
	Params []*string `json:"params,omitempty" tf:"params,omitempty"`

	Worker *WorkerObservation `json:"worker,omitempty" tf:"worker,omitempty"`
}

type OutboundParameters struct {

	// Pass information from the Dispatch Worker to the Outbound Worker through the parameters.
	// +kubebuilder:validation:Optional
	Params []*string `json:"params,omitempty" tf:"params,omitempty"`

	// +kubebuilder:validation:Optional
	Worker *WorkerParameters `json:"worker,omitempty" tf:"worker,omitempty"`
}

type PlacementInitParameters struct {

	// Placement mode for the version.
	// Available values: "smart".
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`
}

type PlacementObservation struct {

	// Placement mode for the version.
	// Available values: "smart".
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`
}

type PlacementParameters struct {

	// Placement mode for the version.
	// Available values: "smart".
	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`
}

type RenamedClassesInitParameters struct {
	From *string `json:"from,omitempty" tf:"from,omitempty"`

	To *string `json:"to,omitempty" tf:"to,omitempty"`
}

type RenamedClassesObservation struct {
	From *string `json:"from,omitempty" tf:"from,omitempty"`

	To *string `json:"to,omitempty" tf:"to,omitempty"`
}

type RenamedClassesParameters struct {

	// +kubebuilder:validation:Optional
	From *string `json:"from,omitempty" tf:"from,omitempty"`

	// +kubebuilder:validation:Optional
	To *string `json:"to,omitempty" tf:"to,omitempty"`
}

type StepsInitParameters struct {

	// A list of classes to delete Durable Object namespaces from.
	DeletedClasses []*string `json:"deletedClasses,omitempty" tf:"deleted_classes,omitempty"`

	// A list of classes to create Durable Object namespaces from.
	NewClasses []*string `json:"newClasses,omitempty" tf:"new_classes,omitempty"`

	// A list of classes to create Durable Object namespaces with SQLite from.
	NewSqliteClasses []*string `json:"newSqliteClasses,omitempty" tf:"new_sqlite_classes,omitempty"`

	RenamedClasses []StepsRenamedClassesInitParameters `json:"renamedClasses,omitempty" tf:"renamed_classes,omitempty"`

	TransferredClasses []TransferredClassesInitParameters `json:"transferredClasses,omitempty" tf:"transferred_classes,omitempty"`
}

type StepsObservation struct {

	// A list of classes to delete Durable Object namespaces from.
	DeletedClasses []*string `json:"deletedClasses,omitempty" tf:"deleted_classes,omitempty"`

	// A list of classes to create Durable Object namespaces from.
	NewClasses []*string `json:"newClasses,omitempty" tf:"new_classes,omitempty"`

	// A list of classes to create Durable Object namespaces with SQLite from.
	NewSqliteClasses []*string `json:"newSqliteClasses,omitempty" tf:"new_sqlite_classes,omitempty"`

	RenamedClasses []StepsRenamedClassesObservation `json:"renamedClasses,omitempty" tf:"renamed_classes,omitempty"`

	TransferredClasses []TransferredClassesObservation `json:"transferredClasses,omitempty" tf:"transferred_classes,omitempty"`
}

type StepsParameters struct {

	// A list of classes to delete Durable Object namespaces from.
	// +kubebuilder:validation:Optional
	DeletedClasses []*string `json:"deletedClasses,omitempty" tf:"deleted_classes,omitempty"`

	// A list of classes to create Durable Object namespaces from.
	// +kubebuilder:validation:Optional
	NewClasses []*string `json:"newClasses,omitempty" tf:"new_classes,omitempty"`

	// A list of classes to create Durable Object namespaces with SQLite from.
	// +kubebuilder:validation:Optional
	NewSqliteClasses []*string `json:"newSqliteClasses,omitempty" tf:"new_sqlite_classes,omitempty"`

	// +kubebuilder:validation:Optional
	RenamedClasses []StepsRenamedClassesParameters `json:"renamedClasses,omitempty" tf:"renamed_classes,omitempty"`

	// +kubebuilder:validation:Optional
	TransferredClasses []TransferredClassesParameters `json:"transferredClasses,omitempty" tf:"transferred_classes,omitempty"`
}

type StepsRenamedClassesInitParameters struct {
	From *string `json:"from,omitempty" tf:"from,omitempty"`

	To *string `json:"to,omitempty" tf:"to,omitempty"`
}

type StepsRenamedClassesObservation struct {
	From *string `json:"from,omitempty" tf:"from,omitempty"`

	To *string `json:"to,omitempty" tf:"to,omitempty"`
}

type StepsRenamedClassesParameters struct {

	// +kubebuilder:validation:Optional
	From *string `json:"from,omitempty" tf:"from,omitempty"`

	// +kubebuilder:validation:Optional
	To *string `json:"to,omitempty" tf:"to,omitempty"`
}

type TransferredClassesInitParameters struct {
	From *string `json:"from,omitempty" tf:"from,omitempty"`

	FromScript *string `json:"fromScript,omitempty" tf:"from_script,omitempty"`

	To *string `json:"to,omitempty" tf:"to,omitempty"`
}

type TransferredClassesObservation struct {
	From *string `json:"from,omitempty" tf:"from,omitempty"`

	FromScript *string `json:"fromScript,omitempty" tf:"from_script,omitempty"`

	To *string `json:"to,omitempty" tf:"to,omitempty"`
}

type TransferredClassesParameters struct {

	// +kubebuilder:validation:Optional
	From *string `json:"from,omitempty" tf:"from,omitempty"`

	// +kubebuilder:validation:Optional
	FromScript *string `json:"fromScript,omitempty" tf:"from_script,omitempty"`

	// +kubebuilder:validation:Optional
	To *string `json:"to,omitempty" tf:"to,omitempty"`
}

type VersionInitParameters struct {

	// Identifier.
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	Annotations *AnnotationsInitParameters `json:"annotations,omitempty" tf:"annotations,omitempty"`

	Assets *AssetsInitParameters `json:"assets,omitempty" tf:"assets,omitempty"`

	Bindings []BindingsInitParameters `json:"bindings,omitempty" tf:"bindings,omitempty"`

	// Date indicating targeted support in the Workers runtime. Backwards incompatible fixes to the runtime following this date will not affect this Worker.
	CompatibilityDate *string `json:"compatibilityDate,omitempty" tf:"compatibility_date,omitempty"`

	// Flags that enable or disable certain features in the Workers runtime. Used to enable upcoming features or opt in or out of specific changes not included in a `compatibility_date`.
	// +listType=set
	CompatibilityFlags []*string `json:"compatibilityFlags,omitempty" tf:"compatibility_flags,omitempty"`

	Limits *LimitsInitParameters `json:"limits,omitempty" tf:"limits,omitempty"`

	// The name of the main module in the `modules` array (e.g. the name of the module that exports a `fetch` handler).
	MainModule *string `json:"mainModule,omitempty" tf:"main_module,omitempty"`

	Migrations *MigrationsInitParameters `json:"migrations,omitempty" tf:"migrations,omitempty"`

	Modules []ModulesInitParameters `json:"modules,omitempty" tf:"modules,omitempty"`

	Placement *PlacementInitParameters `json:"placement,omitempty" tf:"placement,omitempty"`

	// Usage model for the version.
	// Available values: "standard", "bundled", "unbound".
	UsageModel *string `json:"usageModel,omitempty" tf:"usage_model,omitempty"`

	// Identifier for the Worker, which can be ID or name.
	WorkerID *string `json:"workerId,omitempty" tf:"worker_id,omitempty"`
}

type VersionObservation struct {

	// Identifier.
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	Annotations *AnnotationsObservation `json:"annotations,omitempty" tf:"annotations,omitempty"`

	Assets *AssetsObservation `json:"assets,omitempty" tf:"assets,omitempty"`

	Bindings []BindingsObservation `json:"bindings,omitempty" tf:"bindings,omitempty"`

	// Date indicating targeted support in the Workers runtime. Backwards incompatible fixes to the runtime following this date will not affect this Worker.
	CompatibilityDate *string `json:"compatibilityDate,omitempty" tf:"compatibility_date,omitempty"`

	// Flags that enable or disable certain features in the Workers runtime. Used to enable upcoming features or opt in or out of specific changes not included in a `compatibility_date`.
	// +listType=set
	CompatibilityFlags []*string `json:"compatibilityFlags,omitempty" tf:"compatibility_flags,omitempty"`

	// When the version was created.
	CreatedOn *string `json:"createdOn,omitempty" tf:"created_on,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Limits *LimitsObservation `json:"limits,omitempty" tf:"limits,omitempty"`

	// The name of the main module in the `modules` array (e.g. the name of the module that exports a `fetch` handler).
	MainModule *string `json:"mainModule,omitempty" tf:"main_module,omitempty"`

	// The base64-encoded main script content. This is only returned for service worker syntax workers (not ES modules). Used when importing existing workers that use the older service worker syntax.
	MainScriptBase64 *string `json:"mainScriptBase64,omitempty" tf:"main_script_base64,omitempty"`

	Migrations *MigrationsObservation `json:"migrations,omitempty" tf:"migrations,omitempty"`

	Modules []ModulesObservation `json:"modules,omitempty" tf:"modules,omitempty"`

	// The integer version number, starting from one.
	Number *float64 `json:"number,omitempty" tf:"number,omitempty"`

	Placement *PlacementObservation `json:"placement,omitempty" tf:"placement,omitempty"`

	// The client used to create the version.
	Source *string `json:"source,omitempty" tf:"source,omitempty"`

	// Time in milliseconds spent on [Worker startup](https://developers.cloudflare.com/workers/platform/limits/#worker-startup-time).
	StartupTimeMs *float64 `json:"startupTimeMs,omitempty" tf:"startup_time_ms,omitempty"`

	// Usage model for the version.
	// Available values: "standard", "bundled", "unbound".
	UsageModel *string `json:"usageModel,omitempty" tf:"usage_model,omitempty"`

	// Identifier for the Worker, which can be ID or name.
	WorkerID *string `json:"workerId,omitempty" tf:"worker_id,omitempty"`
}

type VersionParameters struct {

	// Identifier.
	// +kubebuilder:validation:Optional
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	// +kubebuilder:validation:Optional
	Annotations *AnnotationsParameters `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// +kubebuilder:validation:Optional
	Assets *AssetsParameters `json:"assets,omitempty" tf:"assets,omitempty"`

	// +kubebuilder:validation:Optional
	Bindings []BindingsParameters `json:"bindings,omitempty" tf:"bindings,omitempty"`

	// Date indicating targeted support in the Workers runtime. Backwards incompatible fixes to the runtime following this date will not affect this Worker.
	// +kubebuilder:validation:Optional
	CompatibilityDate *string `json:"compatibilityDate,omitempty" tf:"compatibility_date,omitempty"`

	// Flags that enable or disable certain features in the Workers runtime. Used to enable upcoming features or opt in or out of specific changes not included in a `compatibility_date`.
	// +kubebuilder:validation:Optional
	// +listType=set
	CompatibilityFlags []*string `json:"compatibilityFlags,omitempty" tf:"compatibility_flags,omitempty"`

	// +kubebuilder:validation:Optional
	Limits *LimitsParameters `json:"limits,omitempty" tf:"limits,omitempty"`

	// The name of the main module in the `modules` array (e.g. the name of the module that exports a `fetch` handler).
	// +kubebuilder:validation:Optional
	MainModule *string `json:"mainModule,omitempty" tf:"main_module,omitempty"`

	// +kubebuilder:validation:Optional
	Migrations *MigrationsParameters `json:"migrations,omitempty" tf:"migrations,omitempty"`

	// +kubebuilder:validation:Optional
	Modules []ModulesParameters `json:"modules,omitempty" tf:"modules,omitempty"`

	// +kubebuilder:validation:Optional
	Placement *PlacementParameters `json:"placement,omitempty" tf:"placement,omitempty"`

	// Usage model for the version.
	// Available values: "standard", "bundled", "unbound".
	// +kubebuilder:validation:Optional
	UsageModel *string `json:"usageModel,omitempty" tf:"usage_model,omitempty"`

	// Identifier for the Worker, which can be ID or name.
	// +kubebuilder:validation:Optional
	WorkerID *string `json:"workerId,omitempty" tf:"worker_id,omitempty"`
}

type WorkerInitParameters struct {

	// Environment of the outbound worker.
	Environment *string `json:"environment,omitempty" tf:"environment,omitempty"`

	// Name of the outbound worker.
	Service *string `json:"service,omitempty" tf:"service,omitempty"`
}

type WorkerObservation struct {

	// Environment of the outbound worker.
	Environment *string `json:"environment,omitempty" tf:"environment,omitempty"`

	// Name of the outbound worker.
	Service *string `json:"service,omitempty" tf:"service,omitempty"`
}

type WorkerParameters struct {

	// Environment of the outbound worker.
	// +kubebuilder:validation:Optional
	Environment *string `json:"environment,omitempty" tf:"environment,omitempty"`

	// Name of the outbound worker.
	// +kubebuilder:validation:Optional
	Service *string `json:"service,omitempty" tf:"service,omitempty"`
}

// VersionSpec defines the desired state of Version
type VersionSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     VersionParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider VersionInitParameters `json:"initProvider,omitempty"`
}

// VersionStatus defines the observed state of Version.
type VersionStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        VersionObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Version is the Schema for the Versions API. <no value>
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,cloudflare}
type Version struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.accountId) || (has(self.initProvider) && has(self.initProvider.accountId))",message="spec.forProvider.accountId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.workerId) || (has(self.initProvider) && has(self.initProvider.workerId))",message="spec.forProvider.workerId is a required parameter"
	Spec   VersionSpec   `json:"spec"`
	Status VersionStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// VersionList contains a list of Versions
type VersionList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Version `json:"items"`
}

// Repository type metadata.
var (
	Version_Kind             = "Version"
	Version_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Version_Kind}.String()
	Version_KindAPIVersion   = Version_Kind + "." + CRDGroupVersion.String()
	Version_GroupVersionKind = CRDGroupVersion.WithKind(Version_Kind)
)

func init() {
	SchemeBuilder.Register(&Version{}, &VersionList{})
}
