// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1common "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
	v1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
)

type DataInitParameters struct {

	// Algorithm.
	Algorithm *float64 `json:"algorithm,omitempty" tf:"algorithm,omitempty"`

	// Altitude of location in meters.
	Altitude *float64 `json:"altitude,omitempty" tf:"altitude,omitempty"`

	// Certificate.
	Certificate *string `json:"certificate,omitempty" tf:"certificate,omitempty"`

	// Digest.
	Digest *string `json:"digest,omitempty" tf:"digest,omitempty"`

	// Digest Type.
	DigestType *float64 `json:"digestType,omitempty" tf:"digest_type,omitempty"`

	// Fingerprint.
	Fingerprint *string `json:"fingerprint,omitempty" tf:"fingerprint,omitempty"`

	// Flags for the CAA record.
	Flags *v1.JSON `json:"flags,omitempty" tf:"flags,omitempty"`

	// Key Tag.
	KeyTag *float64 `json:"keyTag,omitempty" tf:"key_tag,omitempty"`

	// Degrees of latitude.
	LatDegrees *float64 `json:"latDegrees,omitempty" tf:"lat_degrees,omitempty"`

	// Latitude direction.
	// Available values: "N", "S".
	LatDirection *string `json:"latDirection,omitempty" tf:"lat_direction,omitempty"`

	// Minutes of latitude.
	LatMinutes *float64 `json:"latMinutes,omitempty" tf:"lat_minutes,omitempty"`

	// Seconds of latitude.
	LatSeconds *float64 `json:"latSeconds,omitempty" tf:"lat_seconds,omitempty"`

	// Degrees of longitude.
	LongDegrees *float64 `json:"longDegrees,omitempty" tf:"long_degrees,omitempty"`

	// Longitude direction.
	// Available values: "E", "W".
	LongDirection *string `json:"longDirection,omitempty" tf:"long_direction,omitempty"`

	// Minutes of longitude.
	LongMinutes *float64 `json:"longMinutes,omitempty" tf:"long_minutes,omitempty"`

	// Seconds of longitude.
	LongSeconds *float64 `json:"longSeconds,omitempty" tf:"long_seconds,omitempty"`

	// Matching Type.
	MatchingType *float64 `json:"matchingType,omitempty" tf:"matching_type,omitempty"`

	// Order.
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`

	// The port of the service.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// Horizontal precision of location.
	PrecisionHorz *float64 `json:"precisionHorz,omitempty" tf:"precision_horz,omitempty"`

	// Vertical precision of location.
	PrecisionVert *float64 `json:"precisionVert,omitempty" tf:"precision_vert,omitempty"`

	// Preference.
	Preference *float64 `json:"preference,omitempty" tf:"preference,omitempty"`

	// Priority.
	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`

	// Protocol.
	Protocol *float64 `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// Public Key.
	PublicKey *string `json:"publicKey,omitempty" tf:"public_key,omitempty"`

	// Regex.
	Regex *string `json:"regex,omitempty" tf:"regex,omitempty"`

	// Replacement.
	Replacement *string `json:"replacement,omitempty" tf:"replacement,omitempty"`

	// Selector.
	Selector *float64 `json:"selector,omitempty" tf:"selector,omitempty"`

	// Service.
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// Size of location in meters.
	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`

	// Name of the property controlled by this record (e.g.: issue, issuewild, iodef).
	Tag *string `json:"tag,omitempty" tf:"tag,omitempty"`

	// Target.
	Target *string `json:"target,omitempty" tf:"target,omitempty"`

	// Type.
	Type *float64 `json:"type,omitempty" tf:"type,omitempty"`

	// Usage.
	Usage *float64 `json:"usage,omitempty" tf:"usage,omitempty"`

	// Value of the record. This field's semantics depend on the chosen tag.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`

	// The record weight.
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type DataObservation struct {

	// Algorithm.
	Algorithm *float64 `json:"algorithm,omitempty" tf:"algorithm,omitempty"`

	// Altitude of location in meters.
	Altitude *float64 `json:"altitude,omitempty" tf:"altitude,omitempty"`

	// Certificate.
	Certificate *string `json:"certificate,omitempty" tf:"certificate,omitempty"`

	// Digest.
	Digest *string `json:"digest,omitempty" tf:"digest,omitempty"`

	// Digest Type.
	DigestType *float64 `json:"digestType,omitempty" tf:"digest_type,omitempty"`

	// Fingerprint.
	Fingerprint *string `json:"fingerprint,omitempty" tf:"fingerprint,omitempty"`

	// Flags for the CAA record.
	Flags *v1.JSON `json:"flags,omitempty" tf:"flags,omitempty"`

	// Key Tag.
	KeyTag *float64 `json:"keyTag,omitempty" tf:"key_tag,omitempty"`

	// Degrees of latitude.
	LatDegrees *float64 `json:"latDegrees,omitempty" tf:"lat_degrees,omitempty"`

	// Latitude direction.
	// Available values: "N", "S".
	LatDirection *string `json:"latDirection,omitempty" tf:"lat_direction,omitempty"`

	// Minutes of latitude.
	LatMinutes *float64 `json:"latMinutes,omitempty" tf:"lat_minutes,omitempty"`

	// Seconds of latitude.
	LatSeconds *float64 `json:"latSeconds,omitempty" tf:"lat_seconds,omitempty"`

	// Degrees of longitude.
	LongDegrees *float64 `json:"longDegrees,omitempty" tf:"long_degrees,omitempty"`

	// Longitude direction.
	// Available values: "E", "W".
	LongDirection *string `json:"longDirection,omitempty" tf:"long_direction,omitempty"`

	// Minutes of longitude.
	LongMinutes *float64 `json:"longMinutes,omitempty" tf:"long_minutes,omitempty"`

	// Seconds of longitude.
	LongSeconds *float64 `json:"longSeconds,omitempty" tf:"long_seconds,omitempty"`

	// Matching Type.
	MatchingType *float64 `json:"matchingType,omitempty" tf:"matching_type,omitempty"`

	// Order.
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`

	// The port of the service.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// Horizontal precision of location.
	PrecisionHorz *float64 `json:"precisionHorz,omitempty" tf:"precision_horz,omitempty"`

	// Vertical precision of location.
	PrecisionVert *float64 `json:"precisionVert,omitempty" tf:"precision_vert,omitempty"`

	// Preference.
	Preference *float64 `json:"preference,omitempty" tf:"preference,omitempty"`

	// Priority.
	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`

	// Protocol.
	Protocol *float64 `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// Public Key.
	PublicKey *string `json:"publicKey,omitempty" tf:"public_key,omitempty"`

	// Regex.
	Regex *string `json:"regex,omitempty" tf:"regex,omitempty"`

	// Replacement.
	Replacement *string `json:"replacement,omitempty" tf:"replacement,omitempty"`

	// Selector.
	Selector *float64 `json:"selector,omitempty" tf:"selector,omitempty"`

	// Service.
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// Size of location in meters.
	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`

	// Name of the property controlled by this record (e.g.: issue, issuewild, iodef).
	Tag *string `json:"tag,omitempty" tf:"tag,omitempty"`

	// Target.
	Target *string `json:"target,omitempty" tf:"target,omitempty"`

	// Type.
	Type *float64 `json:"type,omitempty" tf:"type,omitempty"`

	// Usage.
	Usage *float64 `json:"usage,omitempty" tf:"usage,omitempty"`

	// Value of the record. This field's semantics depend on the chosen tag.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`

	// The record weight.
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type DataParameters struct {

	// Algorithm.
	// +kubebuilder:validation:Optional
	Algorithm *float64 `json:"algorithm,omitempty" tf:"algorithm,omitempty"`

	// Altitude of location in meters.
	// +kubebuilder:validation:Optional
	Altitude *float64 `json:"altitude,omitempty" tf:"altitude,omitempty"`

	// Certificate.
	// +kubebuilder:validation:Optional
	Certificate *string `json:"certificate,omitempty" tf:"certificate,omitempty"`

	// Digest.
	// +kubebuilder:validation:Optional
	Digest *string `json:"digest,omitempty" tf:"digest,omitempty"`

	// Digest Type.
	// +kubebuilder:validation:Optional
	DigestType *float64 `json:"digestType,omitempty" tf:"digest_type,omitempty"`

	// Fingerprint.
	// +kubebuilder:validation:Optional
	Fingerprint *string `json:"fingerprint,omitempty" tf:"fingerprint,omitempty"`

	// Flags for the CAA record.
	// +kubebuilder:validation:Optional
	Flags *v1.JSON `json:"flags,omitempty" tf:"flags,omitempty"`

	// Key Tag.
	// +kubebuilder:validation:Optional
	KeyTag *float64 `json:"keyTag,omitempty" tf:"key_tag,omitempty"`

	// Degrees of latitude.
	// +kubebuilder:validation:Optional
	LatDegrees *float64 `json:"latDegrees,omitempty" tf:"lat_degrees,omitempty"`

	// Latitude direction.
	// Available values: "N", "S".
	// +kubebuilder:validation:Optional
	LatDirection *string `json:"latDirection,omitempty" tf:"lat_direction,omitempty"`

	// Minutes of latitude.
	// +kubebuilder:validation:Optional
	LatMinutes *float64 `json:"latMinutes,omitempty" tf:"lat_minutes,omitempty"`

	// Seconds of latitude.
	// +kubebuilder:validation:Optional
	LatSeconds *float64 `json:"latSeconds,omitempty" tf:"lat_seconds,omitempty"`

	// Degrees of longitude.
	// +kubebuilder:validation:Optional
	LongDegrees *float64 `json:"longDegrees,omitempty" tf:"long_degrees,omitempty"`

	// Longitude direction.
	// Available values: "E", "W".
	// +kubebuilder:validation:Optional
	LongDirection *string `json:"longDirection,omitempty" tf:"long_direction,omitempty"`

	// Minutes of longitude.
	// +kubebuilder:validation:Optional
	LongMinutes *float64 `json:"longMinutes,omitempty" tf:"long_minutes,omitempty"`

	// Seconds of longitude.
	// +kubebuilder:validation:Optional
	LongSeconds *float64 `json:"longSeconds,omitempty" tf:"long_seconds,omitempty"`

	// Matching Type.
	// +kubebuilder:validation:Optional
	MatchingType *float64 `json:"matchingType,omitempty" tf:"matching_type,omitempty"`

	// Order.
	// +kubebuilder:validation:Optional
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`

	// The port of the service.
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// Horizontal precision of location.
	// +kubebuilder:validation:Optional
	PrecisionHorz *float64 `json:"precisionHorz,omitempty" tf:"precision_horz,omitempty"`

	// Vertical precision of location.
	// +kubebuilder:validation:Optional
	PrecisionVert *float64 `json:"precisionVert,omitempty" tf:"precision_vert,omitempty"`

	// Preference.
	// +kubebuilder:validation:Optional
	Preference *float64 `json:"preference,omitempty" tf:"preference,omitempty"`

	// Priority.
	// +kubebuilder:validation:Optional
	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`

	// Protocol.
	// +kubebuilder:validation:Optional
	Protocol *float64 `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// Public Key.
	// +kubebuilder:validation:Optional
	PublicKey *string `json:"publicKey,omitempty" tf:"public_key,omitempty"`

	// Regex.
	// +kubebuilder:validation:Optional
	Regex *string `json:"regex,omitempty" tf:"regex,omitempty"`

	// Replacement.
	// +kubebuilder:validation:Optional
	Replacement *string `json:"replacement,omitempty" tf:"replacement,omitempty"`

	// Selector.
	// +kubebuilder:validation:Optional
	Selector *float64 `json:"selector,omitempty" tf:"selector,omitempty"`

	// Service.
	// +kubebuilder:validation:Optional
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// Size of location in meters.
	// +kubebuilder:validation:Optional
	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`

	// Name of the property controlled by this record (e.g.: issue, issuewild, iodef).
	// +kubebuilder:validation:Optional
	Tag *string `json:"tag,omitempty" tf:"tag,omitempty"`

	// Target.
	// +kubebuilder:validation:Optional
	Target *string `json:"target,omitempty" tf:"target,omitempty"`

	// Type.
	// +kubebuilder:validation:Optional
	Type *float64 `json:"type,omitempty" tf:"type,omitempty"`

	// Usage.
	// +kubebuilder:validation:Optional
	Usage *float64 `json:"usage,omitempty" tf:"usage,omitempty"`

	// Value of the record. This field's semantics depend on the chosen tag.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`

	// The record weight.
	// +kubebuilder:validation:Optional
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type RecordInitParameters struct {

	// Comments or notes about the DNS record. This field has no effect on DNS responses.
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// A valid IPv4 address.
	Content *string `json:"content,omitempty" tf:"content,omitempty"`

	Data *DataInitParameters `json:"data,omitempty" tf:"data,omitempty"`

	// DNS record name (or @ for the zone apex) in Punycode.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Required for MX, SRV and URI records; unused by other record types. Records with lower priorities are preferred.
	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`

	// Whether the record is receiving the performance and security benefits of Cloudflare.
	Proxied *bool `json:"proxied,omitempty" tf:"proxied,omitempty"`

	Settings *SettingsInitParameters `json:"settings,omitempty" tf:"settings,omitempty"`

	// Time To Live (TTL) of the DNS record in seconds. Setting to 1 means 'automatic'. Value must be between 60 and 86400, with the minimum reduced to 30 for Enterprise zones.
	TTL *float64 `json:"ttl,omitempty" tf:"ttl,omitempty"`

	// Custom tags for the DNS record. This field has no effect on DNS responses.
	// +listType=set
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Record type.
	// Available values: "A", "AAAA", "CNAME", "MX", "NS", "OPENPGPKEY", "PTR", "TXT", "CAA", "CERT", "DNSKEY", "DS", "HTTPS", "LOC", "NAPTR", "SMIMEA", "SRV", "SSHFP", "SVCB", "TLSA", "URI".
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Identifier.
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type RecordObservation struct {

	// Comments or notes about the DNS record. This field has no effect on DNS responses.
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// When the record comment was last modified. Omitted if there is no comment.
	CommentModifiedOn *string `json:"commentModifiedOn,omitempty" tf:"comment_modified_on,omitempty"`

	// A valid IPv4 address.
	Content *string `json:"content,omitempty" tf:"content,omitempty"`

	// When the record was created.
	CreatedOn *string `json:"createdOn,omitempty" tf:"created_on,omitempty"`

	Data *DataObservation `json:"data,omitempty" tf:"data,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Extra Cloudflare-specific information about the record.
	Meta *string `json:"meta,omitempty" tf:"meta,omitempty"`

	// When the record was last modified.
	ModifiedOn *string `json:"modifiedOn,omitempty" tf:"modified_on,omitempty"`

	// DNS record name (or @ for the zone apex) in Punycode.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Required for MX, SRV and URI records; unused by other record types. Records with lower priorities are preferred.
	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`

	// Whether the record can be proxied by Cloudflare or not.
	Proxiable *bool `json:"proxiable,omitempty" tf:"proxiable,omitempty"`

	// Whether the record is receiving the performance and security benefits of Cloudflare.
	Proxied *bool `json:"proxied,omitempty" tf:"proxied,omitempty"`

	Settings *SettingsObservation `json:"settings,omitempty" tf:"settings,omitempty"`

	// Time To Live (TTL) of the DNS record in seconds. Setting to 1 means 'automatic'. Value must be between 60 and 86400, with the minimum reduced to 30 for Enterprise zones.
	TTL *float64 `json:"ttl,omitempty" tf:"ttl,omitempty"`

	// Custom tags for the DNS record. This field has no effect on DNS responses.
	// +listType=set
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// When the record tags were last modified. Omitted if there are no tags.
	TagsModifiedOn *string `json:"tagsModifiedOn,omitempty" tf:"tags_modified_on,omitempty"`

	// Record type.
	// Available values: "A", "AAAA", "CNAME", "MX", "NS", "OPENPGPKEY", "PTR", "TXT", "CAA", "CERT", "DNSKEY", "DS", "HTTPS", "LOC", "NAPTR", "SMIMEA", "SRV", "SSHFP", "SVCB", "TLSA", "URI".
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Identifier.
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type RecordParameters struct {

	// Comments or notes about the DNS record. This field has no effect on DNS responses.
	// +kubebuilder:validation:Optional
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// A valid IPv4 address.
	// +kubebuilder:validation:Optional
	Content *string `json:"content,omitempty" tf:"content,omitempty"`

	// +kubebuilder:validation:Optional
	Data *DataParameters `json:"data,omitempty" tf:"data,omitempty"`

	// DNS record name (or @ for the zone apex) in Punycode.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Required for MX, SRV and URI records; unused by other record types. Records with lower priorities are preferred.
	// +kubebuilder:validation:Optional
	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`

	// Whether the record is receiving the performance and security benefits of Cloudflare.
	// +kubebuilder:validation:Optional
	Proxied *bool `json:"proxied,omitempty" tf:"proxied,omitempty"`

	// +kubebuilder:validation:Optional
	Settings *SettingsParameters `json:"settings,omitempty" tf:"settings,omitempty"`

	// Time To Live (TTL) of the DNS record in seconds. Setting to 1 means 'automatic'. Value must be between 60 and 86400, with the minimum reduced to 30 for Enterprise zones.
	// +kubebuilder:validation:Optional
	TTL *float64 `json:"ttl,omitempty" tf:"ttl,omitempty"`

	// Custom tags for the DNS record. This field has no effect on DNS responses.
	// +kubebuilder:validation:Optional
	// +listType=set
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Record type.
	// Available values: "A", "AAAA", "CNAME", "MX", "NS", "OPENPGPKEY", "PTR", "TXT", "CAA", "CERT", "DNSKEY", "DS", "HTTPS", "LOC", "NAPTR", "SMIMEA", "SRV", "SSHFP", "SVCB", "TLSA", "URI".
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Identifier.
	// +kubebuilder:validation:Optional
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type SettingsInitParameters struct {

	// If enabled, causes the CNAME record to be resolved externally and the resulting address records (e.g., A and AAAA) to be returned instead of the CNAME record itself. This setting is unavailable for proxied records, since they are always flattened.
	FlattenCname *bool `json:"flattenCname,omitempty" tf:"flatten_cname,omitempty"`

	// When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
	IPv4Only *bool `json:"ipv4Only,omitempty" tf:"ipv4_only,omitempty"`

	// When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
	IPv6Only *bool `json:"ipv6Only,omitempty" tf:"ipv6_only,omitempty"`
}

type SettingsObservation struct {

	// If enabled, causes the CNAME record to be resolved externally and the resulting address records (e.g., A and AAAA) to be returned instead of the CNAME record itself. This setting is unavailable for proxied records, since they are always flattened.
	FlattenCname *bool `json:"flattenCname,omitempty" tf:"flatten_cname,omitempty"`

	// When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
	IPv4Only *bool `json:"ipv4Only,omitempty" tf:"ipv4_only,omitempty"`

	// When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
	IPv6Only *bool `json:"ipv6Only,omitempty" tf:"ipv6_only,omitempty"`
}

type SettingsParameters struct {

	// If enabled, causes the CNAME record to be resolved externally and the resulting address records (e.g., A and AAAA) to be returned instead of the CNAME record itself. This setting is unavailable for proxied records, since they are always flattened.
	// +kubebuilder:validation:Optional
	FlattenCname *bool `json:"flattenCname,omitempty" tf:"flatten_cname,omitempty"`

	// When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
	// +kubebuilder:validation:Optional
	IPv4Only *bool `json:"ipv4Only,omitempty" tf:"ipv4_only,omitempty"`

	// When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
	// +kubebuilder:validation:Optional
	IPv6Only *bool `json:"ipv6Only,omitempty" tf:"ipv6_only,omitempty"`
}

// RecordSpec defines the desired state of Record
type RecordSpec struct {
	v1common.ResourceSpec `json:",inline"`
	ForProvider           RecordParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider RecordInitParameters `json:"initProvider,omitempty"`
}

// RecordStatus defines the observed state of Record.
type RecordStatus struct {
	v1common.ResourceStatus `json:",inline"`
	AtProvider              RecordObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Record is the Schema for the Records API. <no value>
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,cloudflare}
type Record struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.ttl) || (has(self.initProvider) && has(self.initProvider.ttl))",message="spec.forProvider.ttl is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.type) || (has(self.initProvider) && has(self.initProvider.type))",message="spec.forProvider.type is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.zoneId) || (has(self.initProvider) && has(self.initProvider.zoneId))",message="spec.forProvider.zoneId is a required parameter"
	Spec   RecordSpec   `json:"spec"`
	Status RecordStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// RecordList contains a list of Records
type RecordList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Record `json:"items"`
}

// Repository type metadata.
var (
	Record_Kind             = "Record"
	Record_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Record_Kind}.String()
	Record_KindAPIVersion   = Record_Kind + "." + CRDGroupVersion.String()
	Record_GroupVersionKind = CRDGroupVersion.WithKind(Record_Kind)
)

func init() {
	SchemeBuilder.Register(&Record{}, &RecordList{})
}
