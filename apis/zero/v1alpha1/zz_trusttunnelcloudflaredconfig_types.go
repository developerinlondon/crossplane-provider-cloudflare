// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
)

type AccessInitParameters struct {

	// Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
	AudTag []*string `json:"audTag,omitempty" tf:"aud_tag,omitempty"`

	// Deny traffic that has not fulfilled Access authorization.
	Required *bool `json:"required,omitempty" tf:"required,omitempty"`

	TeamName *string `json:"teamName,omitempty" tf:"team_name,omitempty"`
}

type AccessObservation struct {

	// Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
	AudTag []*string `json:"audTag,omitempty" tf:"aud_tag,omitempty"`

	// Deny traffic that has not fulfilled Access authorization.
	Required *bool `json:"required,omitempty" tf:"required,omitempty"`

	TeamName *string `json:"teamName,omitempty" tf:"team_name,omitempty"`
}

type AccessParameters struct {

	// Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
	// +kubebuilder:validation:Optional
	AudTag []*string `json:"audTag" tf:"aud_tag,omitempty"`

	// Deny traffic that has not fulfilled Access authorization.
	// +kubebuilder:validation:Optional
	Required *bool `json:"required,omitempty" tf:"required,omitempty"`

	// +kubebuilder:validation:Optional
	TeamName *string `json:"teamName" tf:"team_name,omitempty"`
}

type ConfigOriginRequestInitParameters struct {
	Access *OriginRequestAccessInitParameters `json:"access,omitempty" tf:"access,omitempty"`

	// Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
	CAPool *string `json:"caPool,omitempty" tf:"ca_pool,omitempty"`

	// Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
	ConnectTimeout *float64 `json:"connectTimeout,omitempty" tf:"connect_timeout,omitempty"`

	// Disables chunked transfer encoding. Useful if you are running a WSGI server.
	DisableChunkedEncoding *bool `json:"disableChunkedEncoding,omitempty" tf:"disable_chunked_encoding,omitempty"`

	// Sets the HTTP Host header on requests sent to the local service.
	HTTPHostHeader *string `json:"httpHostHeader,omitempty" tf:"http_host_header,omitempty"`

	// Attempt to connect to origin using HTTP2. Origin must be configured as https.
	Http2Origin *bool `json:"http2Origin,omitempty" tf:"http2_origin,omitempty"`

	// Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
	KeepAliveConnections *float64 `json:"keepAliveConnections,omitempty" tf:"keep_alive_connections,omitempty"`

	// Timeout after which an idle keepalive connection can be discarded.
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty" tf:"keep_alive_timeout,omitempty"`

	// Auto configure the Hostname on the origin server certificate.
	MatchSnItoHost *bool `json:"matchSnItoHost,omitempty" tf:"match_sn_ito_host,omitempty"`

	// Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
	NoHappyEyeballs *bool `json:"noHappyEyeballs,omitempty" tf:"no_happy_eyeballs,omitempty"`

	// Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
	NoTLSVerify *bool `json:"noTlsVerify,omitempty" tf:"no_tls_verify,omitempty"`

	// Hostname that cloudflared should expect from your origin server certificate.
	OriginServerName *string `json:"originServerName,omitempty" tf:"origin_server_name,omitempty"`

	// cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
	ProxyType *string `json:"proxyType,omitempty" tf:"proxy_type,omitempty"`

	// The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
	TCPKeepAlive *float64 `json:"tcpKeepAlive,omitempty" tf:"tcp_keep_alive,omitempty"`

	// Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
	TLSTimeout *float64 `json:"tlsTimeout,omitempty" tf:"tls_timeout,omitempty"`
}

type ConfigOriginRequestObservation struct {
	Access *OriginRequestAccessObservation `json:"access,omitempty" tf:"access,omitempty"`

	// Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
	CAPool *string `json:"caPool,omitempty" tf:"ca_pool,omitempty"`

	// Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
	ConnectTimeout *float64 `json:"connectTimeout,omitempty" tf:"connect_timeout,omitempty"`

	// Disables chunked transfer encoding. Useful if you are running a WSGI server.
	DisableChunkedEncoding *bool `json:"disableChunkedEncoding,omitempty" tf:"disable_chunked_encoding,omitempty"`

	// Sets the HTTP Host header on requests sent to the local service.
	HTTPHostHeader *string `json:"httpHostHeader,omitempty" tf:"http_host_header,omitempty"`

	// Attempt to connect to origin using HTTP2. Origin must be configured as https.
	Http2Origin *bool `json:"http2Origin,omitempty" tf:"http2_origin,omitempty"`

	// Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
	KeepAliveConnections *float64 `json:"keepAliveConnections,omitempty" tf:"keep_alive_connections,omitempty"`

	// Timeout after which an idle keepalive connection can be discarded.
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty" tf:"keep_alive_timeout,omitempty"`

	// Auto configure the Hostname on the origin server certificate.
	MatchSnItoHost *bool `json:"matchSnItoHost,omitempty" tf:"match_sn_ito_host,omitempty"`

	// Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
	NoHappyEyeballs *bool `json:"noHappyEyeballs,omitempty" tf:"no_happy_eyeballs,omitempty"`

	// Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
	NoTLSVerify *bool `json:"noTlsVerify,omitempty" tf:"no_tls_verify,omitempty"`

	// Hostname that cloudflared should expect from your origin server certificate.
	OriginServerName *string `json:"originServerName,omitempty" tf:"origin_server_name,omitempty"`

	// cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
	ProxyType *string `json:"proxyType,omitempty" tf:"proxy_type,omitempty"`

	// The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
	TCPKeepAlive *float64 `json:"tcpKeepAlive,omitempty" tf:"tcp_keep_alive,omitempty"`

	// Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
	TLSTimeout *float64 `json:"tlsTimeout,omitempty" tf:"tls_timeout,omitempty"`
}

type ConfigOriginRequestParameters struct {

	// +kubebuilder:validation:Optional
	Access *OriginRequestAccessParameters `json:"access,omitempty" tf:"access,omitempty"`

	// Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
	// +kubebuilder:validation:Optional
	CAPool *string `json:"caPool,omitempty" tf:"ca_pool,omitempty"`

	// Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
	// +kubebuilder:validation:Optional
	ConnectTimeout *float64 `json:"connectTimeout,omitempty" tf:"connect_timeout,omitempty"`

	// Disables chunked transfer encoding. Useful if you are running a WSGI server.
	// +kubebuilder:validation:Optional
	DisableChunkedEncoding *bool `json:"disableChunkedEncoding,omitempty" tf:"disable_chunked_encoding,omitempty"`

	// Sets the HTTP Host header on requests sent to the local service.
	// +kubebuilder:validation:Optional
	HTTPHostHeader *string `json:"httpHostHeader,omitempty" tf:"http_host_header,omitempty"`

	// Attempt to connect to origin using HTTP2. Origin must be configured as https.
	// +kubebuilder:validation:Optional
	Http2Origin *bool `json:"http2Origin,omitempty" tf:"http2_origin,omitempty"`

	// Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
	// +kubebuilder:validation:Optional
	KeepAliveConnections *float64 `json:"keepAliveConnections,omitempty" tf:"keep_alive_connections,omitempty"`

	// Timeout after which an idle keepalive connection can be discarded.
	// +kubebuilder:validation:Optional
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty" tf:"keep_alive_timeout,omitempty"`

	// Auto configure the Hostname on the origin server certificate.
	// +kubebuilder:validation:Optional
	MatchSnItoHost *bool `json:"matchSnItoHost,omitempty" tf:"match_sn_ito_host,omitempty"`

	// Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
	// +kubebuilder:validation:Optional
	NoHappyEyeballs *bool `json:"noHappyEyeballs,omitempty" tf:"no_happy_eyeballs,omitempty"`

	// Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
	// +kubebuilder:validation:Optional
	NoTLSVerify *bool `json:"noTlsVerify,omitempty" tf:"no_tls_verify,omitempty"`

	// Hostname that cloudflared should expect from your origin server certificate.
	// +kubebuilder:validation:Optional
	OriginServerName *string `json:"originServerName,omitempty" tf:"origin_server_name,omitempty"`

	// cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
	// +kubebuilder:validation:Optional
	ProxyType *string `json:"proxyType,omitempty" tf:"proxy_type,omitempty"`

	// The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
	// +kubebuilder:validation:Optional
	TCPKeepAlive *float64 `json:"tcpKeepAlive,omitempty" tf:"tcp_keep_alive,omitempty"`

	// Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
	// +kubebuilder:validation:Optional
	TLSTimeout *float64 `json:"tlsTimeout,omitempty" tf:"tls_timeout,omitempty"`
}

type IngressInitParameters struct {

	// Public hostname for this service.
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	OriginRequest *OriginRequestInitParameters `json:"originRequest,omitempty" tf:"origin_request,omitempty"`

	// Requests with this path route to this public hostname.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// Protocol and address of destination server. Supported protocols: http://, https://, unix://, tcp://, ssh://, rdp://, unix+tls://, smb://. Alternatively can return a HTTP status code http_status:[code] e.g. 'http_status:404'.
	Service *string `json:"service,omitempty" tf:"service,omitempty"`
}

type IngressObservation struct {

	// Public hostname for this service.
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	OriginRequest *OriginRequestObservation `json:"originRequest,omitempty" tf:"origin_request,omitempty"`

	// Requests with this path route to this public hostname.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// Protocol and address of destination server. Supported protocols: http://, https://, unix://, tcp://, ssh://, rdp://, unix+tls://, smb://. Alternatively can return a HTTP status code http_status:[code] e.g. 'http_status:404'.
	Service *string `json:"service,omitempty" tf:"service,omitempty"`
}

type IngressParameters struct {

	// Public hostname for this service.
	// +kubebuilder:validation:Optional
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	// +kubebuilder:validation:Optional
	OriginRequest *OriginRequestParameters `json:"originRequest,omitempty" tf:"origin_request,omitempty"`

	// Requests with this path route to this public hostname.
	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// Protocol and address of destination server. Supported protocols: http://, https://, unix://, tcp://, ssh://, rdp://, unix+tls://, smb://. Alternatively can return a HTTP status code http_status:[code] e.g. 'http_status:404'.
	// +kubebuilder:validation:Optional
	Service *string `json:"service" tf:"service,omitempty"`
}

type OriginRequestAccessInitParameters struct {

	// Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
	AudTag []*string `json:"audTag,omitempty" tf:"aud_tag,omitempty"`

	// Deny traffic that has not fulfilled Access authorization.
	Required *bool `json:"required,omitempty" tf:"required,omitempty"`

	TeamName *string `json:"teamName,omitempty" tf:"team_name,omitempty"`
}

type OriginRequestAccessObservation struct {

	// Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
	AudTag []*string `json:"audTag,omitempty" tf:"aud_tag,omitempty"`

	// Deny traffic that has not fulfilled Access authorization.
	Required *bool `json:"required,omitempty" tf:"required,omitempty"`

	TeamName *string `json:"teamName,omitempty" tf:"team_name,omitempty"`
}

type OriginRequestAccessParameters struct {

	// Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
	// +kubebuilder:validation:Optional
	AudTag []*string `json:"audTag" tf:"aud_tag,omitempty"`

	// Deny traffic that has not fulfilled Access authorization.
	// +kubebuilder:validation:Optional
	Required *bool `json:"required,omitempty" tf:"required,omitempty"`

	// +kubebuilder:validation:Optional
	TeamName *string `json:"teamName" tf:"team_name,omitempty"`
}

type OriginRequestInitParameters struct {
	Access *AccessInitParameters `json:"access,omitempty" tf:"access,omitempty"`

	// Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
	CAPool *string `json:"caPool,omitempty" tf:"ca_pool,omitempty"`

	// Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
	ConnectTimeout *float64 `json:"connectTimeout,omitempty" tf:"connect_timeout,omitempty"`

	// Disables chunked transfer encoding. Useful if you are running a WSGI server.
	DisableChunkedEncoding *bool `json:"disableChunkedEncoding,omitempty" tf:"disable_chunked_encoding,omitempty"`

	// Sets the HTTP Host header on requests sent to the local service.
	HTTPHostHeader *string `json:"httpHostHeader,omitempty" tf:"http_host_header,omitempty"`

	// Attempt to connect to origin using HTTP2. Origin must be configured as https.
	Http2Origin *bool `json:"http2Origin,omitempty" tf:"http2_origin,omitempty"`

	// Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
	KeepAliveConnections *float64 `json:"keepAliveConnections,omitempty" tf:"keep_alive_connections,omitempty"`

	// Timeout after which an idle keepalive connection can be discarded.
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty" tf:"keep_alive_timeout,omitempty"`

	// Auto configure the Hostname on the origin server certificate.
	MatchSnItoHost *bool `json:"matchSnItoHost,omitempty" tf:"match_sn_ito_host,omitempty"`

	// Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
	NoHappyEyeballs *bool `json:"noHappyEyeballs,omitempty" tf:"no_happy_eyeballs,omitempty"`

	// Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
	NoTLSVerify *bool `json:"noTlsVerify,omitempty" tf:"no_tls_verify,omitempty"`

	// Hostname that cloudflared should expect from your origin server certificate.
	OriginServerName *string `json:"originServerName,omitempty" tf:"origin_server_name,omitempty"`

	// cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
	ProxyType *string `json:"proxyType,omitempty" tf:"proxy_type,omitempty"`

	// The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
	TCPKeepAlive *float64 `json:"tcpKeepAlive,omitempty" tf:"tcp_keep_alive,omitempty"`

	// Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
	TLSTimeout *float64 `json:"tlsTimeout,omitempty" tf:"tls_timeout,omitempty"`
}

type OriginRequestObservation struct {
	Access *AccessObservation `json:"access,omitempty" tf:"access,omitempty"`

	// Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
	CAPool *string `json:"caPool,omitempty" tf:"ca_pool,omitempty"`

	// Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
	ConnectTimeout *float64 `json:"connectTimeout,omitempty" tf:"connect_timeout,omitempty"`

	// Disables chunked transfer encoding. Useful if you are running a WSGI server.
	DisableChunkedEncoding *bool `json:"disableChunkedEncoding,omitempty" tf:"disable_chunked_encoding,omitempty"`

	// Sets the HTTP Host header on requests sent to the local service.
	HTTPHostHeader *string `json:"httpHostHeader,omitempty" tf:"http_host_header,omitempty"`

	// Attempt to connect to origin using HTTP2. Origin must be configured as https.
	Http2Origin *bool `json:"http2Origin,omitempty" tf:"http2_origin,omitempty"`

	// Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
	KeepAliveConnections *float64 `json:"keepAliveConnections,omitempty" tf:"keep_alive_connections,omitempty"`

	// Timeout after which an idle keepalive connection can be discarded.
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty" tf:"keep_alive_timeout,omitempty"`

	// Auto configure the Hostname on the origin server certificate.
	MatchSnItoHost *bool `json:"matchSnItoHost,omitempty" tf:"match_sn_ito_host,omitempty"`

	// Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
	NoHappyEyeballs *bool `json:"noHappyEyeballs,omitempty" tf:"no_happy_eyeballs,omitempty"`

	// Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
	NoTLSVerify *bool `json:"noTlsVerify,omitempty" tf:"no_tls_verify,omitempty"`

	// Hostname that cloudflared should expect from your origin server certificate.
	OriginServerName *string `json:"originServerName,omitempty" tf:"origin_server_name,omitempty"`

	// cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
	ProxyType *string `json:"proxyType,omitempty" tf:"proxy_type,omitempty"`

	// The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
	TCPKeepAlive *float64 `json:"tcpKeepAlive,omitempty" tf:"tcp_keep_alive,omitempty"`

	// Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
	TLSTimeout *float64 `json:"tlsTimeout,omitempty" tf:"tls_timeout,omitempty"`
}

type OriginRequestParameters struct {

	// +kubebuilder:validation:Optional
	Access *AccessParameters `json:"access,omitempty" tf:"access,omitempty"`

	// Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
	// +kubebuilder:validation:Optional
	CAPool *string `json:"caPool,omitempty" tf:"ca_pool,omitempty"`

	// Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
	// +kubebuilder:validation:Optional
	ConnectTimeout *float64 `json:"connectTimeout,omitempty" tf:"connect_timeout,omitempty"`

	// Disables chunked transfer encoding. Useful if you are running a WSGI server.
	// +kubebuilder:validation:Optional
	DisableChunkedEncoding *bool `json:"disableChunkedEncoding,omitempty" tf:"disable_chunked_encoding,omitempty"`

	// Sets the HTTP Host header on requests sent to the local service.
	// +kubebuilder:validation:Optional
	HTTPHostHeader *string `json:"httpHostHeader,omitempty" tf:"http_host_header,omitempty"`

	// Attempt to connect to origin using HTTP2. Origin must be configured as https.
	// +kubebuilder:validation:Optional
	Http2Origin *bool `json:"http2Origin,omitempty" tf:"http2_origin,omitempty"`

	// Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
	// +kubebuilder:validation:Optional
	KeepAliveConnections *float64 `json:"keepAliveConnections,omitempty" tf:"keep_alive_connections,omitempty"`

	// Timeout after which an idle keepalive connection can be discarded.
	// +kubebuilder:validation:Optional
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty" tf:"keep_alive_timeout,omitempty"`

	// Auto configure the Hostname on the origin server certificate.
	// +kubebuilder:validation:Optional
	MatchSnItoHost *bool `json:"matchSnItoHost,omitempty" tf:"match_sn_ito_host,omitempty"`

	// Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
	// +kubebuilder:validation:Optional
	NoHappyEyeballs *bool `json:"noHappyEyeballs,omitempty" tf:"no_happy_eyeballs,omitempty"`

	// Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
	// +kubebuilder:validation:Optional
	NoTLSVerify *bool `json:"noTlsVerify,omitempty" tf:"no_tls_verify,omitempty"`

	// Hostname that cloudflared should expect from your origin server certificate.
	// +kubebuilder:validation:Optional
	OriginServerName *string `json:"originServerName,omitempty" tf:"origin_server_name,omitempty"`

	// cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
	// +kubebuilder:validation:Optional
	ProxyType *string `json:"proxyType,omitempty" tf:"proxy_type,omitempty"`

	// The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
	// +kubebuilder:validation:Optional
	TCPKeepAlive *float64 `json:"tcpKeepAlive,omitempty" tf:"tcp_keep_alive,omitempty"`

	// Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
	// +kubebuilder:validation:Optional
	TLSTimeout *float64 `json:"tlsTimeout,omitempty" tf:"tls_timeout,omitempty"`
}

type TrustTunnelCloudflaredConfigConfigInitParameters struct {
	Ingress []IngressInitParameters `json:"ingress,omitempty" tf:"ingress,omitempty"`

	OriginRequest *ConfigOriginRequestInitParameters `json:"originRequest,omitempty" tf:"origin_request,omitempty"`
}

type TrustTunnelCloudflaredConfigConfigObservation struct {
	Ingress []IngressObservation `json:"ingress,omitempty" tf:"ingress,omitempty"`

	OriginRequest *ConfigOriginRequestObservation `json:"originRequest,omitempty" tf:"origin_request,omitempty"`
}

type TrustTunnelCloudflaredConfigConfigParameters struct {

	// +kubebuilder:validation:Optional
	Ingress []IngressParameters `json:"ingress,omitempty" tf:"ingress,omitempty"`

	// +kubebuilder:validation:Optional
	OriginRequest *ConfigOriginRequestParameters `json:"originRequest,omitempty" tf:"origin_request,omitempty"`
}

type TrustTunnelCloudflaredConfigInitParameters struct {

	// Identifier.
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	Config *TrustTunnelCloudflaredConfigConfigInitParameters `json:"config,omitempty" tf:"config,omitempty"`

	// Indicates if this is a locally or remotely configured tunnel. If `local`, manage the tunnel using a YAML file on the origin machine. If `cloudflare`, manage the tunnel's configuration on the Zero Trust dashboard.
	// Available values: "local", "cloudflare".
	Source *string `json:"source,omitempty" tf:"source,omitempty"`

	// UUID of the tunnel.
	TunnelID *string `json:"tunnelId,omitempty" tf:"tunnel_id,omitempty"`
}

type TrustTunnelCloudflaredConfigObservation struct {

	// Identifier.
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	Config *TrustTunnelCloudflaredConfigConfigObservation `json:"config,omitempty" tf:"config,omitempty"`

	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Indicates if this is a locally or remotely configured tunnel. If `local`, manage the tunnel using a YAML file on the origin machine. If `cloudflare`, manage the tunnel's configuration on the Zero Trust dashboard.
	// Available values: "local", "cloudflare".
	Source *string `json:"source,omitempty" tf:"source,omitempty"`

	// UUID of the tunnel.
	TunnelID *string `json:"tunnelId,omitempty" tf:"tunnel_id,omitempty"`

	// The version of the Tunnel Configuration.
	Version *float64 `json:"version,omitempty" tf:"version,omitempty"`
}

type TrustTunnelCloudflaredConfigParameters struct {

	// Identifier.
	// +kubebuilder:validation:Optional
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	// +kubebuilder:validation:Optional
	Config *TrustTunnelCloudflaredConfigConfigParameters `json:"config,omitempty" tf:"config,omitempty"`

	// Indicates if this is a locally or remotely configured tunnel. If `local`, manage the tunnel using a YAML file on the origin machine. If `cloudflare`, manage the tunnel's configuration on the Zero Trust dashboard.
	// Available values: "local", "cloudflare".
	// +kubebuilder:validation:Optional
	Source *string `json:"source,omitempty" tf:"source,omitempty"`

	// UUID of the tunnel.
	// +kubebuilder:validation:Optional
	TunnelID *string `json:"tunnelId,omitempty" tf:"tunnel_id,omitempty"`
}

// TrustTunnelCloudflaredConfigSpec defines the desired state of TrustTunnelCloudflaredConfig
type TrustTunnelCloudflaredConfigSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     TrustTunnelCloudflaredConfigParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider TrustTunnelCloudflaredConfigInitParameters `json:"initProvider,omitempty"`
}

// TrustTunnelCloudflaredConfigStatus defines the observed state of TrustTunnelCloudflaredConfig.
type TrustTunnelCloudflaredConfigStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        TrustTunnelCloudflaredConfigObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// TrustTunnelCloudflaredConfig is the Schema for the TrustTunnelCloudflaredConfigs API. <no value>
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,cloudflare}
type TrustTunnelCloudflaredConfig struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.accountId) || (has(self.initProvider) && has(self.initProvider.accountId))",message="spec.forProvider.accountId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.tunnelId) || (has(self.initProvider) && has(self.initProvider.tunnelId))",message="spec.forProvider.tunnelId is a required parameter"
	Spec   TrustTunnelCloudflaredConfigSpec   `json:"spec"`
	Status TrustTunnelCloudflaredConfigStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// TrustTunnelCloudflaredConfigList contains a list of TrustTunnelCloudflaredConfigs
type TrustTunnelCloudflaredConfigList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []TrustTunnelCloudflaredConfig `json:"items"`
}

// Repository type metadata.
var (
	TrustTunnelCloudflaredConfig_Kind             = "TrustTunnelCloudflaredConfig"
	TrustTunnelCloudflaredConfig_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: TrustTunnelCloudflaredConfig_Kind}.String()
	TrustTunnelCloudflaredConfig_KindAPIVersion   = TrustTunnelCloudflaredConfig_Kind + "." + CRDGroupVersion.String()
	TrustTunnelCloudflaredConfig_GroupVersionKind = CRDGroupVersion.WithKind(TrustTunnelCloudflaredConfig_Kind)
)

func init() {
	SchemeBuilder.Register(&TrustTunnelCloudflaredConfig{}, &TrustTunnelCloudflaredConfigList{})
}
