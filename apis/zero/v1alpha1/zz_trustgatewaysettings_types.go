// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
)

type ActivityLogInitParameters struct {

	// Specify whether to log activity.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type ActivityLogObservation struct {

	// Specify whether to log activity.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type ActivityLogParameters struct {

	// Specify whether to log activity.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type AntivirusInitParameters struct {

	// Specify whether to enable anti-virus scanning on downloads.
	EnabledDownloadPhase *bool `json:"enabledDownloadPhase,omitempty" tf:"enabled_download_phase,omitempty"`

	// Specify whether to enable anti-virus scanning on uploads.
	EnabledUploadPhase *bool `json:"enabledUploadPhase,omitempty" tf:"enabled_upload_phase,omitempty"`

	// Specify whether to block requests for unscannable files.
	FailClosed *bool `json:"failClosed,omitempty" tf:"fail_closed,omitempty"`

	NotificationSettings *AntivirusNotificationSettingsInitParameters `json:"notificationSettings,omitempty" tf:"notification_settings,omitempty"`
}

type AntivirusNotificationSettingsInitParameters struct {

	// Specify whether to enable notifications.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// Specify whether to include context information as query parameters.
	IncludeContext *bool `json:"includeContext,omitempty" tf:"include_context,omitempty"`

	// Specify the message to show in the notification.
	Msg *string `json:"msg,omitempty" tf:"msg,omitempty"`

	// Specify a URL that directs users to more information. If unset, the notification opens a block page.
	SupportURL *string `json:"supportUrl,omitempty" tf:"support_url,omitempty"`
}

type AntivirusNotificationSettingsObservation struct {

	// Specify whether to enable notifications.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// Specify whether to include context information as query parameters.
	IncludeContext *bool `json:"includeContext,omitempty" tf:"include_context,omitempty"`

	// Specify the message to show in the notification.
	Msg *string `json:"msg,omitempty" tf:"msg,omitempty"`

	// Specify a URL that directs users to more information. If unset, the notification opens a block page.
	SupportURL *string `json:"supportUrl,omitempty" tf:"support_url,omitempty"`
}

type AntivirusNotificationSettingsParameters struct {

	// Specify whether to enable notifications.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// Specify whether to include context information as query parameters.
	// +kubebuilder:validation:Optional
	IncludeContext *bool `json:"includeContext,omitempty" tf:"include_context,omitempty"`

	// Specify the message to show in the notification.
	// +kubebuilder:validation:Optional
	Msg *string `json:"msg,omitempty" tf:"msg,omitempty"`

	// Specify a URL that directs users to more information. If unset, the notification opens a block page.
	// +kubebuilder:validation:Optional
	SupportURL *string `json:"supportUrl,omitempty" tf:"support_url,omitempty"`
}

type AntivirusObservation struct {

	// Specify whether to enable anti-virus scanning on downloads.
	EnabledDownloadPhase *bool `json:"enabledDownloadPhase,omitempty" tf:"enabled_download_phase,omitempty"`

	// Specify whether to enable anti-virus scanning on uploads.
	EnabledUploadPhase *bool `json:"enabledUploadPhase,omitempty" tf:"enabled_upload_phase,omitempty"`

	// Specify whether to block requests for unscannable files.
	FailClosed *bool `json:"failClosed,omitempty" tf:"fail_closed,omitempty"`

	NotificationSettings *AntivirusNotificationSettingsObservation `json:"notificationSettings,omitempty" tf:"notification_settings,omitempty"`
}

type AntivirusParameters struct {

	// Specify whether to enable anti-virus scanning on downloads.
	// +kubebuilder:validation:Optional
	EnabledDownloadPhase *bool `json:"enabledDownloadPhase,omitempty" tf:"enabled_download_phase,omitempty"`

	// Specify whether to enable anti-virus scanning on uploads.
	// +kubebuilder:validation:Optional
	EnabledUploadPhase *bool `json:"enabledUploadPhase,omitempty" tf:"enabled_upload_phase,omitempty"`

	// Specify whether to block requests for unscannable files.
	// +kubebuilder:validation:Optional
	FailClosed *bool `json:"failClosed,omitempty" tf:"fail_closed,omitempty"`

	// +kubebuilder:validation:Optional
	NotificationSettings *AntivirusNotificationSettingsParameters `json:"notificationSettings,omitempty" tf:"notification_settings,omitempty"`
}

type BodyScanningInitParameters struct {

	// Specify the inspection mode as either `deep` or `shallow`.
	// Available values: "deep", "shallow".
	InspectionMode *string `json:"inspectionMode,omitempty" tf:"inspection_mode,omitempty"`
}

type BodyScanningObservation struct {

	// Specify the inspection mode as either `deep` or `shallow`.
	// Available values: "deep", "shallow".
	InspectionMode *string `json:"inspectionMode,omitempty" tf:"inspection_mode,omitempty"`
}

type BodyScanningParameters struct {

	// Specify the inspection mode as either `deep` or `shallow`.
	// Available values: "deep", "shallow".
	// +kubebuilder:validation:Optional
	InspectionMode *string `json:"inspectionMode,omitempty" tf:"inspection_mode,omitempty"`
}

type BrowserIsolationInitParameters struct {

	// Specify whether to enable non-identity onramp support for Browser Isolation.
	NonIdentityEnabled *bool `json:"nonIdentityEnabled,omitempty" tf:"non_identity_enabled,omitempty"`

	// Specify whether to enable Clientless Browser Isolation.
	URLBrowserIsolationEnabled *bool `json:"urlBrowserIsolationEnabled,omitempty" tf:"url_browser_isolation_enabled,omitempty"`
}

type BrowserIsolationObservation struct {

	// Specify whether to enable non-identity onramp support for Browser Isolation.
	NonIdentityEnabled *bool `json:"nonIdentityEnabled,omitempty" tf:"non_identity_enabled,omitempty"`

	// Specify whether to enable Clientless Browser Isolation.
	URLBrowserIsolationEnabled *bool `json:"urlBrowserIsolationEnabled,omitempty" tf:"url_browser_isolation_enabled,omitempty"`
}

type BrowserIsolationParameters struct {

	// Specify whether to enable non-identity onramp support for Browser Isolation.
	// +kubebuilder:validation:Optional
	NonIdentityEnabled *bool `json:"nonIdentityEnabled,omitempty" tf:"non_identity_enabled,omitempty"`

	// Specify whether to enable Clientless Browser Isolation.
	// +kubebuilder:validation:Optional
	URLBrowserIsolationEnabled *bool `json:"urlBrowserIsolationEnabled,omitempty" tf:"url_browser_isolation_enabled,omitempty"`
}

type CustomCertificateInitParameters struct {

	// Indicate the internal certificate status.
	BindingStatus *string `json:"bindingStatus,omitempty" tf:"binding_status,omitempty"`

	// Specify whether to enable a custom certificate authority for signing Gateway traffic.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// Specify the UUID of the certificate (ID from MTLS certificate store).
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	UpdatedAt *string `json:"updatedAt,omitempty" tf:"updated_at,omitempty"`
}

type CustomCertificateObservation struct {

	// Indicate the internal certificate status.
	BindingStatus *string `json:"bindingStatus,omitempty" tf:"binding_status,omitempty"`

	// Specify whether to enable a custom certificate authority for signing Gateway traffic.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// Specify the UUID of the certificate (ID from MTLS certificate store).
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	UpdatedAt *string `json:"updatedAt,omitempty" tf:"updated_at,omitempty"`
}

type CustomCertificateParameters struct {

	// Indicate the internal certificate status.
	// +kubebuilder:validation:Optional
	BindingStatus *string `json:"bindingStatus,omitempty" tf:"binding_status,omitempty"`

	// Specify whether to enable a custom certificate authority for signing Gateway traffic.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled" tf:"enabled,omitempty"`

	// Specify the UUID of the certificate (ID from MTLS certificate store).
	// +kubebuilder:validation:Optional
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// +kubebuilder:validation:Optional
	UpdatedAt *string `json:"updatedAt,omitempty" tf:"updated_at,omitempty"`
}

type ExtendedEmailMatchingInitParameters struct {

	// Specify whether to match all variants of user emails (with + or . modifiers) used as criteria in Firewall policies.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// Indicate that this setting was shared via the Orgs API and read only for the current account.
	ReadOnly *bool `json:"readOnly,omitempty" tf:"read_only,omitempty"`

	// Indicate the account tag of the account that shared this setting.
	SourceAccount *string `json:"sourceAccount,omitempty" tf:"source_account,omitempty"`

	// Indicate the version number of the setting.
	Version *float64 `json:"version,omitempty" tf:"version,omitempty"`
}

type ExtendedEmailMatchingObservation struct {

	// Specify whether to match all variants of user emails (with + or . modifiers) used as criteria in Firewall policies.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// Indicate that this setting was shared via the Orgs API and read only for the current account.
	ReadOnly *bool `json:"readOnly,omitempty" tf:"read_only,omitempty"`

	// Indicate the account tag of the account that shared this setting.
	SourceAccount *string `json:"sourceAccount,omitempty" tf:"source_account,omitempty"`

	// Indicate the version number of the setting.
	Version *float64 `json:"version,omitempty" tf:"version,omitempty"`
}

type ExtendedEmailMatchingParameters struct {

	// Specify whether to match all variants of user emails (with + or . modifiers) used as criteria in Firewall policies.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// Indicate that this setting was shared via the Orgs API and read only for the current account.
	// +kubebuilder:validation:Optional
	ReadOnly *bool `json:"readOnly,omitempty" tf:"read_only,omitempty"`

	// Indicate the account tag of the account that shared this setting.
	// +kubebuilder:validation:Optional
	SourceAccount *string `json:"sourceAccount,omitempty" tf:"source_account,omitempty"`

	// Indicate the version number of the setting.
	// +kubebuilder:validation:Optional
	Version *float64 `json:"version,omitempty" tf:"version,omitempty"`
}

type FipsInitParameters struct {

	// Enforce cipher suites and TLS versions compliant with FIPS 140-2.
	TLS *bool `json:"tls,omitempty" tf:"tls,omitempty"`
}

type FipsObservation struct {

	// Enforce cipher suites and TLS versions compliant with FIPS 140-2.
	TLS *bool `json:"tls,omitempty" tf:"tls,omitempty"`
}

type FipsParameters struct {

	// Enforce cipher suites and TLS versions compliant with FIPS 140-2.
	// +kubebuilder:validation:Optional
	TLS *bool `json:"tls,omitempty" tf:"tls,omitempty"`
}

type HostSelectorInitParameters struct {

	// Specify whether to enable filtering via hosts for egress policies.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type HostSelectorObservation struct {

	// Specify whether to enable filtering via hosts for egress policies.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type HostSelectorParameters struct {

	// Specify whether to enable filtering via hosts for egress policies.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type InspectionInitParameters struct {

	// Define the proxy inspection mode.   1. static: Gateway applies static inspection to HTTP on TCP(80). With TLS decryption on, Gateway inspects HTTPS traffic on TCP(443) and UDP(443).   2. dynamic: Gateway applies protocol detection to inspect HTTP and HTTPS traffic on any port. TLS decryption must remain on to inspect HTTPS traffic.
	// Available values: "static", "dynamic".
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`
}

type InspectionObservation struct {

	// Define the proxy inspection mode.   1. static: Gateway applies static inspection to HTTP on TCP(80). With TLS decryption on, Gateway inspects HTTPS traffic on TCP(443) and UDP(443).   2. dynamic: Gateway applies protocol detection to inspect HTTP and HTTPS traffic on any port. TLS decryption must remain on to inspect HTTPS traffic.
	// Available values: "static", "dynamic".
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`
}

type InspectionParameters struct {

	// Define the proxy inspection mode.   1. static: Gateway applies static inspection to HTTP on TCP(80). With TLS decryption on, Gateway inspects HTTPS traffic on TCP(443) and UDP(443).   2. dynamic: Gateway applies protocol detection to inspect HTTP and HTTPS traffic on any port. TLS decryption must remain on to inspect HTTPS traffic.
	// Available values: "static", "dynamic".
	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`
}

type ProtocolDetectionInitParameters struct {

	// Specify whether to detect protocols from the initial bytes of client traffic.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type ProtocolDetectionObservation struct {

	// Specify whether to detect protocols from the initial bytes of client traffic.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type ProtocolDetectionParameters struct {

	// Specify whether to detect protocols from the initial bytes of client traffic.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type SandboxInitParameters struct {

	// Specify whether to enable the sandbox.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// Specify the action to take when the system cannot scan the file.
	// Available values: "allow", "block".
	FallbackAction *string `json:"fallbackAction,omitempty" tf:"fallback_action,omitempty"`
}

type SandboxObservation struct {

	// Specify whether to enable the sandbox.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// Specify the action to take when the system cannot scan the file.
	// Available values: "allow", "block".
	FallbackAction *string `json:"fallbackAction,omitempty" tf:"fallback_action,omitempty"`
}

type SandboxParameters struct {

	// Specify whether to enable the sandbox.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// Specify the action to take when the system cannot scan the file.
	// Available values: "allow", "block".
	// +kubebuilder:validation:Optional
	FallbackAction *string `json:"fallbackAction,omitempty" tf:"fallback_action,omitempty"`
}

type SettingsBlockPageInitParameters struct {

	// Specify the block page background color in `#rrggbb` format when the mode is customized_block_page.
	BackgroundColor *string `json:"backgroundColor,omitempty" tf:"background_color,omitempty"`

	// Specify whether to enable the custom block page.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// Specify the block page footer text when the mode is customized_block_page.
	FooterText *string `json:"footerText,omitempty" tf:"footer_text,omitempty"`

	// Specify the block page header text when the mode is customized_block_page.
	HeaderText *string `json:"headerText,omitempty" tf:"header_text,omitempty"`

	// Specify whether to append context to target_uri as query parameters. This applies only when the mode is redirect_uri.
	IncludeContext *bool `json:"includeContext,omitempty" tf:"include_context,omitempty"`

	// Specify the full URL to the logo file when the mode is customized_block_page.
	LogoPath *string `json:"logoPath,omitempty" tf:"logo_path,omitempty"`

	// Specify the admin email for users to contact when the mode is customized_block_page.
	MailtoAddress *string `json:"mailtoAddress,omitempty" tf:"mailto_address,omitempty"`

	// Specify the subject line for emails created from the block page when the mode is customized_block_page.
	MailtoSubject *string `json:"mailtoSubject,omitempty" tf:"mailto_subject,omitempty"`

	// Specify whether to redirect users to a Cloudflare-hosted block page or a customer-provided URI.
	// Available values: "", "customized_block_page", "redirect_uri".
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// Specify the block page title when the mode is customized_block_page.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Indicate that this setting was shared via the Orgs API and read only for the current account.
	ReadOnly *bool `json:"readOnly,omitempty" tf:"read_only,omitempty"`

	// Indicate the account tag of the account that shared this setting.
	SourceAccount *string `json:"sourceAccount,omitempty" tf:"source_account,omitempty"`

	// Specify whether to suppress detailed information at the bottom of the block page when the mode is customized_block_page.
	SuppressFooter *bool `json:"suppressFooter,omitempty" tf:"suppress_footer,omitempty"`

	// Specify the URI to redirect users to when the mode is redirect_uri.
	TargetURI *string `json:"targetUri,omitempty" tf:"target_uri,omitempty"`

	// Indicate the version number of the setting.
	Version *float64 `json:"version,omitempty" tf:"version,omitempty"`
}

type SettingsBlockPageObservation struct {

	// Specify the block page background color in `#rrggbb` format when the mode is customized_block_page.
	BackgroundColor *string `json:"backgroundColor,omitempty" tf:"background_color,omitempty"`

	// Specify whether to enable the custom block page.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// Specify the block page footer text when the mode is customized_block_page.
	FooterText *string `json:"footerText,omitempty" tf:"footer_text,omitempty"`

	// Specify the block page header text when the mode is customized_block_page.
	HeaderText *string `json:"headerText,omitempty" tf:"header_text,omitempty"`

	// Specify whether to append context to target_uri as query parameters. This applies only when the mode is redirect_uri.
	IncludeContext *bool `json:"includeContext,omitempty" tf:"include_context,omitempty"`

	// Specify the full URL to the logo file when the mode is customized_block_page.
	LogoPath *string `json:"logoPath,omitempty" tf:"logo_path,omitempty"`

	// Specify the admin email for users to contact when the mode is customized_block_page.
	MailtoAddress *string `json:"mailtoAddress,omitempty" tf:"mailto_address,omitempty"`

	// Specify the subject line for emails created from the block page when the mode is customized_block_page.
	MailtoSubject *string `json:"mailtoSubject,omitempty" tf:"mailto_subject,omitempty"`

	// Specify whether to redirect users to a Cloudflare-hosted block page or a customer-provided URI.
	// Available values: "", "customized_block_page", "redirect_uri".
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// Specify the block page title when the mode is customized_block_page.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Indicate that this setting was shared via the Orgs API and read only for the current account.
	ReadOnly *bool `json:"readOnly,omitempty" tf:"read_only,omitempty"`

	// Indicate the account tag of the account that shared this setting.
	SourceAccount *string `json:"sourceAccount,omitempty" tf:"source_account,omitempty"`

	// Specify whether to suppress detailed information at the bottom of the block page when the mode is customized_block_page.
	SuppressFooter *bool `json:"suppressFooter,omitempty" tf:"suppress_footer,omitempty"`

	// Specify the URI to redirect users to when the mode is redirect_uri.
	TargetURI *string `json:"targetUri,omitempty" tf:"target_uri,omitempty"`

	// Indicate the version number of the setting.
	Version *float64 `json:"version,omitempty" tf:"version,omitempty"`
}

type SettingsBlockPageParameters struct {

	// Specify the block page background color in `#rrggbb` format when the mode is customized_block_page.
	// +kubebuilder:validation:Optional
	BackgroundColor *string `json:"backgroundColor,omitempty" tf:"background_color,omitempty"`

	// Specify whether to enable the custom block page.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// Specify the block page footer text when the mode is customized_block_page.
	// +kubebuilder:validation:Optional
	FooterText *string `json:"footerText,omitempty" tf:"footer_text,omitempty"`

	// Specify the block page header text when the mode is customized_block_page.
	// +kubebuilder:validation:Optional
	HeaderText *string `json:"headerText,omitempty" tf:"header_text,omitempty"`

	// Specify whether to append context to target_uri as query parameters. This applies only when the mode is redirect_uri.
	// +kubebuilder:validation:Optional
	IncludeContext *bool `json:"includeContext,omitempty" tf:"include_context,omitempty"`

	// Specify the full URL to the logo file when the mode is customized_block_page.
	// +kubebuilder:validation:Optional
	LogoPath *string `json:"logoPath,omitempty" tf:"logo_path,omitempty"`

	// Specify the admin email for users to contact when the mode is customized_block_page.
	// +kubebuilder:validation:Optional
	MailtoAddress *string `json:"mailtoAddress,omitempty" tf:"mailto_address,omitempty"`

	// Specify the subject line for emails created from the block page when the mode is customized_block_page.
	// +kubebuilder:validation:Optional
	MailtoSubject *string `json:"mailtoSubject,omitempty" tf:"mailto_subject,omitempty"`

	// Specify whether to redirect users to a Cloudflare-hosted block page or a customer-provided URI.
	// Available values: "", "customized_block_page", "redirect_uri".
	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// Specify the block page title when the mode is customized_block_page.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Indicate that this setting was shared via the Orgs API and read only for the current account.
	// +kubebuilder:validation:Optional
	ReadOnly *bool `json:"readOnly,omitempty" tf:"read_only,omitempty"`

	// Indicate the account tag of the account that shared this setting.
	// +kubebuilder:validation:Optional
	SourceAccount *string `json:"sourceAccount,omitempty" tf:"source_account,omitempty"`

	// Specify whether to suppress detailed information at the bottom of the block page when the mode is customized_block_page.
	// +kubebuilder:validation:Optional
	SuppressFooter *bool `json:"suppressFooter,omitempty" tf:"suppress_footer,omitempty"`

	// Specify the URI to redirect users to when the mode is redirect_uri.
	// +kubebuilder:validation:Optional
	TargetURI *string `json:"targetUri,omitempty" tf:"target_uri,omitempty"`

	// Indicate the version number of the setting.
	// +kubebuilder:validation:Optional
	Version *float64 `json:"version,omitempty" tf:"version,omitempty"`
}

type SettingsCertificateInitParameters struct {

	// Specify the UUID of the certificate used for interception. Ensure the certificate is available at the edge(previously called 'active'). A nil UUID directs Cloudflare to use the Root CA.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type SettingsCertificateObservation struct {

	// Specify the UUID of the certificate used for interception. Ensure the certificate is available at the edge(previously called 'active'). A nil UUID directs Cloudflare to use the Root CA.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type SettingsCertificateParameters struct {

	// Specify the UUID of the certificate used for interception. Ensure the certificate is available at the edge(previously called 'active'). A nil UUID directs Cloudflare to use the Root CA.
	// +kubebuilder:validation:Optional
	ID *string `json:"id" tf:"id,omitempty"`
}

type TLSDecryptInitParameters struct {

	// Specify whether to inspect encrypted HTTP traffic.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type TLSDecryptObservation struct {

	// Specify whether to inspect encrypted HTTP traffic.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type TLSDecryptParameters struct {

	// Specify whether to inspect encrypted HTTP traffic.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type TrustGatewaySettingsInitParameters struct {
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	Settings *TrustGatewaySettingsSettingsInitParameters `json:"settings,omitempty" tf:"settings,omitempty"`
}

type TrustGatewaySettingsObservation struct {
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Settings *TrustGatewaySettingsSettingsObservation `json:"settings,omitempty" tf:"settings,omitempty"`

	UpdatedAt *string `json:"updatedAt,omitempty" tf:"updated_at,omitempty"`
}

type TrustGatewaySettingsParameters struct {

	// +kubebuilder:validation:Optional
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	// +kubebuilder:validation:Optional
	Settings *TrustGatewaySettingsSettingsParameters `json:"settings,omitempty" tf:"settings,omitempty"`
}

type TrustGatewaySettingsSettingsInitParameters struct {
	ActivityLog *ActivityLogInitParameters `json:"activityLog,omitempty" tf:"activity_log,omitempty"`

	Antivirus *AntivirusInitParameters `json:"antivirus,omitempty" tf:"antivirus,omitempty"`

	BlockPage *SettingsBlockPageInitParameters `json:"blockPage,omitempty" tf:"block_page,omitempty"`

	BodyScanning *BodyScanningInitParameters `json:"bodyScanning,omitempty" tf:"body_scanning,omitempty"`

	BrowserIsolation *BrowserIsolationInitParameters `json:"browserIsolation,omitempty" tf:"browser_isolation,omitempty"`

	Certificate *SettingsCertificateInitParameters `json:"certificate,omitempty" tf:"certificate,omitempty"`

	CustomCertificate *CustomCertificateInitParameters `json:"customCertificate,omitempty" tf:"custom_certificate,omitempty"`

	ExtendedEmailMatching *ExtendedEmailMatchingInitParameters `json:"extendedEmailMatching,omitempty" tf:"extended_email_matching,omitempty"`

	Fips *FipsInitParameters `json:"fips,omitempty" tf:"fips,omitempty"`

	HostSelector *HostSelectorInitParameters `json:"hostSelector,omitempty" tf:"host_selector,omitempty"`

	Inspection *InspectionInitParameters `json:"inspection,omitempty" tf:"inspection,omitempty"`

	ProtocolDetection *ProtocolDetectionInitParameters `json:"protocolDetection,omitempty" tf:"protocol_detection,omitempty"`

	Sandbox *SandboxInitParameters `json:"sandbox,omitempty" tf:"sandbox,omitempty"`

	TLSDecrypt *TLSDecryptInitParameters `json:"tlsDecrypt,omitempty" tf:"tls_decrypt,omitempty"`
}

type TrustGatewaySettingsSettingsObservation struct {
	ActivityLog *ActivityLogObservation `json:"activityLog,omitempty" tf:"activity_log,omitempty"`

	Antivirus *AntivirusObservation `json:"antivirus,omitempty" tf:"antivirus,omitempty"`

	BlockPage *SettingsBlockPageObservation `json:"blockPage,omitempty" tf:"block_page,omitempty"`

	BodyScanning *BodyScanningObservation `json:"bodyScanning,omitempty" tf:"body_scanning,omitempty"`

	BrowserIsolation *BrowserIsolationObservation `json:"browserIsolation,omitempty" tf:"browser_isolation,omitempty"`

	Certificate *SettingsCertificateObservation `json:"certificate,omitempty" tf:"certificate,omitempty"`

	CustomCertificate *CustomCertificateObservation `json:"customCertificate,omitempty" tf:"custom_certificate,omitempty"`

	ExtendedEmailMatching *ExtendedEmailMatchingObservation `json:"extendedEmailMatching,omitempty" tf:"extended_email_matching,omitempty"`

	Fips *FipsObservation `json:"fips,omitempty" tf:"fips,omitempty"`

	HostSelector *HostSelectorObservation `json:"hostSelector,omitempty" tf:"host_selector,omitempty"`

	Inspection *InspectionObservation `json:"inspection,omitempty" tf:"inspection,omitempty"`

	ProtocolDetection *ProtocolDetectionObservation `json:"protocolDetection,omitempty" tf:"protocol_detection,omitempty"`

	Sandbox *SandboxObservation `json:"sandbox,omitempty" tf:"sandbox,omitempty"`

	TLSDecrypt *TLSDecryptObservation `json:"tlsDecrypt,omitempty" tf:"tls_decrypt,omitempty"`
}

type TrustGatewaySettingsSettingsParameters struct {

	// +kubebuilder:validation:Optional
	ActivityLog *ActivityLogParameters `json:"activityLog,omitempty" tf:"activity_log,omitempty"`

	// +kubebuilder:validation:Optional
	Antivirus *AntivirusParameters `json:"antivirus,omitempty" tf:"antivirus,omitempty"`

	// +kubebuilder:validation:Optional
	BlockPage *SettingsBlockPageParameters `json:"blockPage,omitempty" tf:"block_page,omitempty"`

	// +kubebuilder:validation:Optional
	BodyScanning *BodyScanningParameters `json:"bodyScanning,omitempty" tf:"body_scanning,omitempty"`

	// +kubebuilder:validation:Optional
	BrowserIsolation *BrowserIsolationParameters `json:"browserIsolation,omitempty" tf:"browser_isolation,omitempty"`

	// +kubebuilder:validation:Optional
	Certificate *SettingsCertificateParameters `json:"certificate,omitempty" tf:"certificate,omitempty"`

	// +kubebuilder:validation:Optional
	CustomCertificate *CustomCertificateParameters `json:"customCertificate,omitempty" tf:"custom_certificate,omitempty"`

	// +kubebuilder:validation:Optional
	ExtendedEmailMatching *ExtendedEmailMatchingParameters `json:"extendedEmailMatching,omitempty" tf:"extended_email_matching,omitempty"`

	// +kubebuilder:validation:Optional
	Fips *FipsParameters `json:"fips,omitempty" tf:"fips,omitempty"`

	// +kubebuilder:validation:Optional
	HostSelector *HostSelectorParameters `json:"hostSelector,omitempty" tf:"host_selector,omitempty"`

	// +kubebuilder:validation:Optional
	Inspection *InspectionParameters `json:"inspection,omitempty" tf:"inspection,omitempty"`

	// +kubebuilder:validation:Optional
	ProtocolDetection *ProtocolDetectionParameters `json:"protocolDetection,omitempty" tf:"protocol_detection,omitempty"`

	// +kubebuilder:validation:Optional
	Sandbox *SandboxParameters `json:"sandbox,omitempty" tf:"sandbox,omitempty"`

	// +kubebuilder:validation:Optional
	TLSDecrypt *TLSDecryptParameters `json:"tlsDecrypt,omitempty" tf:"tls_decrypt,omitempty"`
}

// TrustGatewaySettingsSpec defines the desired state of TrustGatewaySettings
type TrustGatewaySettingsSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     TrustGatewaySettingsParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider TrustGatewaySettingsInitParameters `json:"initProvider,omitempty"`
}

// TrustGatewaySettingsStatus defines the observed state of TrustGatewaySettings.
type TrustGatewaySettingsStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        TrustGatewaySettingsObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// TrustGatewaySettings is the Schema for the TrustGatewaySettingss API. <no value>
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,cloudflare}
type TrustGatewaySettings struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.accountId) || (has(self.initProvider) && has(self.initProvider.accountId))",message="spec.forProvider.accountId is a required parameter"
	Spec   TrustGatewaySettingsSpec   `json:"spec"`
	Status TrustGatewaySettingsStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// TrustGatewaySettingsList contains a list of TrustGatewaySettingss
type TrustGatewaySettingsList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []TrustGatewaySettings `json:"items"`
}

// Repository type metadata.
var (
	TrustGatewaySettings_Kind             = "TrustGatewaySettings"
	TrustGatewaySettings_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: TrustGatewaySettings_Kind}.String()
	TrustGatewaySettings_KindAPIVersion   = TrustGatewaySettings_Kind + "." + CRDGroupVersion.String()
	TrustGatewaySettings_GroupVersionKind = CRDGroupVersion.WithKind(TrustGatewaySettings_Kind)
)

func init() {
	SchemeBuilder.Register(&TrustGatewaySettings{}, &TrustGatewaySettingsList{})
}
