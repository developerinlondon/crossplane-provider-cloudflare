// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
)

type BalancerMonitorInitParameters struct {

	// Identifier.
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	// Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors.
	AllowInsecure *bool `json:"allowInsecure,omitempty" tf:"allow_insecure,omitempty"`

	// To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times.
	ConsecutiveDown *float64 `json:"consecutiveDown,omitempty" tf:"consecutive_down,omitempty"`

	// To be marked healthy the monitored origin must pass this healthcheck N consecutive times.
	ConsecutiveUp *float64 `json:"consecutiveUp,omitempty" tf:"consecutive_up,omitempty"`

	// Object description.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors.
	ExpectedBody *string `json:"expectedBody,omitempty" tf:"expected_body,omitempty"`

	// The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors.
	ExpectedCodes *string `json:"expectedCodes,omitempty" tf:"expected_codes,omitempty"`

	// Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors.
	FollowRedirects *bool `json:"followRedirects,omitempty" tf:"follow_redirects,omitempty"`

	// The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden. This parameter is only valid for HTTP and HTTPS monitors.
	Header map[string][]*string `json:"header,omitempty" tf:"header,omitempty"`

	// The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations.
	Interval *float64 `json:"interval,omitempty" tf:"interval,omitempty"`

	// The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks.
	Method *string `json:"method,omitempty" tf:"method,omitempty"`

	// The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443).
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors.
	ProbeZone *string `json:"probeZone,omitempty" tf:"probe_zone,omitempty"`

	// The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately.
	Retries *float64 `json:"retries,omitempty" tf:"retries,omitempty"`

	// The timeout (in seconds) before marking the health check as failed.
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// The protocol to use for the health check. Currently supported protocols are 'HTTP','HTTPS', 'TCP', 'ICMP-PING', 'UDP-ICMP', and 'SMTP'.
	// Available values: "http", "https", "tcp", "udp_icmp", "icmp_ping", "smtp".
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type BalancerMonitorObservation struct {

	// Identifier.
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	// Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors.
	AllowInsecure *bool `json:"allowInsecure,omitempty" tf:"allow_insecure,omitempty"`

	// To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times.
	ConsecutiveDown *float64 `json:"consecutiveDown,omitempty" tf:"consecutive_down,omitempty"`

	// To be marked healthy the monitored origin must pass this healthcheck N consecutive times.
	ConsecutiveUp *float64 `json:"consecutiveUp,omitempty" tf:"consecutive_up,omitempty"`

	CreatedOn *string `json:"createdOn,omitempty" tf:"created_on,omitempty"`

	// Object description.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors.
	ExpectedBody *string `json:"expectedBody,omitempty" tf:"expected_body,omitempty"`

	// The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors.
	ExpectedCodes *string `json:"expectedCodes,omitempty" tf:"expected_codes,omitempty"`

	// Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors.
	FollowRedirects *bool `json:"followRedirects,omitempty" tf:"follow_redirects,omitempty"`

	// The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden. This parameter is only valid for HTTP and HTTPS monitors.
	Header map[string][]*string `json:"header,omitempty" tf:"header,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations.
	Interval *float64 `json:"interval,omitempty" tf:"interval,omitempty"`

	// The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks.
	Method *string `json:"method,omitempty" tf:"method,omitempty"`

	ModifiedOn *string `json:"modifiedOn,omitempty" tf:"modified_on,omitempty"`

	// The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443).
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors.
	ProbeZone *string `json:"probeZone,omitempty" tf:"probe_zone,omitempty"`

	// The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately.
	Retries *float64 `json:"retries,omitempty" tf:"retries,omitempty"`

	// The timeout (in seconds) before marking the health check as failed.
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// The protocol to use for the health check. Currently supported protocols are 'HTTP','HTTPS', 'TCP', 'ICMP-PING', 'UDP-ICMP', and 'SMTP'.
	// Available values: "http", "https", "tcp", "udp_icmp", "icmp_ping", "smtp".
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type BalancerMonitorParameters struct {

	// Identifier.
	// +kubebuilder:validation:Optional
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	// Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors.
	// +kubebuilder:validation:Optional
	AllowInsecure *bool `json:"allowInsecure,omitempty" tf:"allow_insecure,omitempty"`

	// To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times.
	// +kubebuilder:validation:Optional
	ConsecutiveDown *float64 `json:"consecutiveDown,omitempty" tf:"consecutive_down,omitempty"`

	// To be marked healthy the monitored origin must pass this healthcheck N consecutive times.
	// +kubebuilder:validation:Optional
	ConsecutiveUp *float64 `json:"consecutiveUp,omitempty" tf:"consecutive_up,omitempty"`

	// Object description.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors.
	// +kubebuilder:validation:Optional
	ExpectedBody *string `json:"expectedBody,omitempty" tf:"expected_body,omitempty"`

	// The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors.
	// +kubebuilder:validation:Optional
	ExpectedCodes *string `json:"expectedCodes,omitempty" tf:"expected_codes,omitempty"`

	// Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors.
	// +kubebuilder:validation:Optional
	FollowRedirects *bool `json:"followRedirects,omitempty" tf:"follow_redirects,omitempty"`

	// The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden. This parameter is only valid for HTTP and HTTPS monitors.
	// +kubebuilder:validation:Optional
	Header map[string][]*string `json:"header,omitempty" tf:"header,omitempty"`

	// The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations.
	// +kubebuilder:validation:Optional
	Interval *float64 `json:"interval,omitempty" tf:"interval,omitempty"`

	// The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks.
	// +kubebuilder:validation:Optional
	Method *string `json:"method,omitempty" tf:"method,omitempty"`

	// The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors.
	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443).
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors.
	// +kubebuilder:validation:Optional
	ProbeZone *string `json:"probeZone,omitempty" tf:"probe_zone,omitempty"`

	// The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately.
	// +kubebuilder:validation:Optional
	Retries *float64 `json:"retries,omitempty" tf:"retries,omitempty"`

	// The timeout (in seconds) before marking the health check as failed.
	// +kubebuilder:validation:Optional
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// The protocol to use for the health check. Currently supported protocols are 'HTTP','HTTPS', 'TCP', 'ICMP-PING', 'UDP-ICMP', and 'SMTP'.
	// Available values: "http", "https", "tcp", "udp_icmp", "icmp_ping", "smtp".
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

// BalancerMonitorSpec defines the desired state of BalancerMonitor
type BalancerMonitorSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     BalancerMonitorParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider BalancerMonitorInitParameters `json:"initProvider,omitempty"`
}

// BalancerMonitorStatus defines the observed state of BalancerMonitor.
type BalancerMonitorStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        BalancerMonitorObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// BalancerMonitor is the Schema for the BalancerMonitors API. <no value>
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,cloudflare}
type BalancerMonitor struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.accountId) || (has(self.initProvider) && has(self.initProvider.accountId))",message="spec.forProvider.accountId is a required parameter"
	Spec   BalancerMonitorSpec   `json:"spec"`
	Status BalancerMonitorStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// BalancerMonitorList contains a list of BalancerMonitors
type BalancerMonitorList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []BalancerMonitor `json:"items"`
}

// Repository type metadata.
var (
	BalancerMonitor_Kind             = "BalancerMonitor"
	BalancerMonitor_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: BalancerMonitor_Kind}.String()
	BalancerMonitor_KindAPIVersion   = BalancerMonitor_Kind + "." + CRDGroupVersion.String()
	BalancerMonitor_GroupVersionKind = CRDGroupVersion.WithKind(BalancerMonitor_Kind)
)

func init() {
	SchemeBuilder.Register(&BalancerMonitor{}, &BalancerMonitorList{})
}
