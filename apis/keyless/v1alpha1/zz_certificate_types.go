// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
)

type CertificateInitParameters struct {

	// A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
	// Available values: "ubiquitous", "optimal", "force".
	BundleMethod *string `json:"bundleMethod,omitempty" tf:"bundle_method,omitempty"`

	// The zone's SSL certificate or SSL certificate and intermediate(s).
	Certificate *string `json:"certificate,omitempty" tf:"certificate,omitempty"`

	// Whether or not the Keyless SSL is on or off.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The keyless SSL name.
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// The keyless SSL name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	Tunnel *TunnelInitParameters `json:"tunnel,omitempty" tf:"tunnel,omitempty"`

	// Identifier.
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type CertificateObservation struct {

	// A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
	// Available values: "ubiquitous", "optimal", "force".
	BundleMethod *string `json:"bundleMethod,omitempty" tf:"bundle_method,omitempty"`

	// The zone's SSL certificate or SSL certificate and intermediate(s).
	Certificate *string `json:"certificate,omitempty" tf:"certificate,omitempty"`

	// When the Keyless SSL was created.
	CreatedOn *string `json:"createdOn,omitempty" tf:"created_on,omitempty"`

	// Whether or not the Keyless SSL is on or off.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The keyless SSL name.
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// When the Keyless SSL was last modified.
	ModifiedOn *string `json:"modifiedOn,omitempty" tf:"modified_on,omitempty"`

	// The keyless SSL name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Available permissions for the Keyless SSL for the current user requesting the item.
	Permissions []*string `json:"permissions,omitempty" tf:"permissions,omitempty"`

	// The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// Status of the Keyless SSL.
	// Available values: "active", "deleted".
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	Tunnel *TunnelObservation `json:"tunnel,omitempty" tf:"tunnel,omitempty"`

	// Identifier.
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type CertificateParameters struct {

	// A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
	// Available values: "ubiquitous", "optimal", "force".
	// +kubebuilder:validation:Optional
	BundleMethod *string `json:"bundleMethod,omitempty" tf:"bundle_method,omitempty"`

	// The zone's SSL certificate or SSL certificate and intermediate(s).
	// +kubebuilder:validation:Optional
	Certificate *string `json:"certificate,omitempty" tf:"certificate,omitempty"`

	// Whether or not the Keyless SSL is on or off.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The keyless SSL name.
	// +kubebuilder:validation:Optional
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// The keyless SSL name.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel *TunnelParameters `json:"tunnel,omitempty" tf:"tunnel,omitempty"`

	// Identifier.
	// +kubebuilder:validation:Optional
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type TunnelInitParameters struct {

	// Private IP of the Key Server Host
	PrivateIP *string `json:"privateIp,omitempty" tf:"private_ip,omitempty"`

	// Cloudflare Tunnel Virtual Network ID
	VnetID *string `json:"vnetId,omitempty" tf:"vnet_id,omitempty"`
}

type TunnelObservation struct {

	// Private IP of the Key Server Host
	PrivateIP *string `json:"privateIp,omitempty" tf:"private_ip,omitempty"`

	// Cloudflare Tunnel Virtual Network ID
	VnetID *string `json:"vnetId,omitempty" tf:"vnet_id,omitempty"`
}

type TunnelParameters struct {

	// Private IP of the Key Server Host
	// +kubebuilder:validation:Optional
	PrivateIP *string `json:"privateIp" tf:"private_ip,omitempty"`

	// Cloudflare Tunnel Virtual Network ID
	// +kubebuilder:validation:Optional
	VnetID *string `json:"vnetId" tf:"vnet_id,omitempty"`
}

// CertificateSpec defines the desired state of Certificate
type CertificateSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     CertificateParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider CertificateInitParameters `json:"initProvider,omitempty"`
}

// CertificateStatus defines the observed state of Certificate.
type CertificateStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        CertificateObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Certificate is the Schema for the Certificates API. <no value>
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,cloudflare}
type Certificate struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.certificate) || (has(self.initProvider) && has(self.initProvider.certificate))",message="spec.forProvider.certificate is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.host) || (has(self.initProvider) && has(self.initProvider.host))",message="spec.forProvider.host is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.zoneId) || (has(self.initProvider) && has(self.initProvider.zoneId))",message="spec.forProvider.zoneId is a required parameter"
	Spec   CertificateSpec   `json:"spec"`
	Status CertificateStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// CertificateList contains a list of Certificates
type CertificateList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Certificate `json:"items"`
}

// Repository type metadata.
var (
	Certificate_Kind             = "Certificate"
	Certificate_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Certificate_Kind}.String()
	Certificate_KindAPIVersion   = Certificate_Kind + "." + CRDGroupVersion.String()
	Certificate_GroupVersionKind = CRDGroupVersion.WithKind(Certificate_Kind)
)

func init() {
	SchemeBuilder.Register(&Certificate{}, &CertificateList{})
}
