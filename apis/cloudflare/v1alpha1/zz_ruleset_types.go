// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
)

type ActionParametersInitParameters struct {

	// A list of additional ports that caching should be enabled on.
	AdditionalCacheablePorts []*float64 `json:"additionalCacheablePorts,omitempty" tf:"additional_cacheable_ports,omitempty"`

	Algorithms []AlgorithmsInitParameters `json:"algorithms,omitempty" tf:"algorithms,omitempty"`

	// The name of a custom asset to serve as the response.
	AssetName *string `json:"assetName,omitempty" tf:"asset_name,omitempty"`

	// Whether to enable Automatic HTTPS Rewrites.
	AutomaticHTTPSRewrites *bool `json:"automaticHttpsRewrites,omitempty" tf:"automatic_https_rewrites,omitempty"`

	Autominify *AutominifyInitParameters `json:"autominify,omitempty" tf:"autominify,omitempty"`

	// Whether to enable Browser Integrity Check (BIC).
	Bic *bool `json:"bic,omitempty" tf:"bic,omitempty"`

	BrowserTTL *BrowserTTLInitParameters `json:"browserTtl,omitempty" tf:"browser_ttl,omitempty"`

	// Whether the request's response from the origin is eligible for caching. Caching itself will still depend on the cache control header and your other caching configurations.
	Cache *bool `json:"cache,omitempty" tf:"cache,omitempty"`

	CacheKey *CacheKeyInitParameters `json:"cacheKey,omitempty" tf:"cache_key,omitempty"`

	CacheReserve *CacheReserveInitParameters `json:"cacheReserve,omitempty" tf:"cache_reserve,omitempty"`

	// The response content.
	Content *string `json:"content,omitempty" tf:"content,omitempty"`

	// The content type header to set with the error response.
	// Available values: "application/json", "text/html", "text/plain", "text/xml".
	ContentType *string `json:"contentType,omitempty" tf:"content_type,omitempty"`

	CookieFields []CookieFieldsInitParameters `json:"cookieFields,omitempty" tf:"cookie_fields,omitempty"`

	// Whether to disable Cloudflare Apps.
	DisableApps *bool `json:"disableApps,omitempty" tf:"disable_apps,omitempty"`

	// Whether to disable Real User Monitoring (RUM).
	DisableRum *bool `json:"disableRum,omitempty" tf:"disable_rum,omitempty"`

	// Whether to disable Zaraz.
	DisableZaraz *bool `json:"disableZaraz,omitempty" tf:"disable_zaraz,omitempty"`

	EdgeTTL *EdgeTTLInitParameters `json:"edgeTtl,omitempty" tf:"edge_ttl,omitempty"`

	// Whether to enable Email Obfuscation.
	EmailObfuscation *bool `json:"emailObfuscation,omitempty" tf:"email_obfuscation,omitempty"`

	// Whether to enable Cloudflare Fonts.
	Fonts *bool `json:"fonts,omitempty" tf:"fonts,omitempty"`

	FromList *FromListInitParameters `json:"fromList,omitempty" tf:"from_list,omitempty"`

	FromValue *FromValueInitParameters `json:"fromValue,omitempty" tf:"from_value,omitempty"`

	Headers map[string]HeadersInitParameters `json:"headers,omitempty" tf:"headers,omitempty"`

	// A value to rewrite the HTTP host header to.
	HostHeader *string `json:"hostHeader,omitempty" tf:"host_header,omitempty"`

	// Whether to enable Hotlink Protection.
	HotlinkProtection *bool `json:"hotlinkProtection,omitempty" tf:"hotlink_protection,omitempty"`

	// The ID of the ruleset to execute.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// A delta to change the score by, which can be either positive or negative.
	Increment *float64 `json:"increment,omitempty" tf:"increment,omitempty"`

	MatchedData *MatchedDataInitParameters `json:"matchedData,omitempty" tf:"matched_data,omitempty"`

	// Whether to enable Mirage.
	Mirage *bool `json:"mirage,omitempty" tf:"mirage,omitempty"`

	// Whether to enable Opportunistic Encryption.
	OpportunisticEncryption *bool `json:"opportunisticEncryption,omitempty" tf:"opportunistic_encryption,omitempty"`

	Origin *OriginInitParameters `json:"origin,omitempty" tf:"origin,omitempty"`

	// Whether Cloudflare will aim to strictly adhere to RFC 7234.
	OriginCacheControl *bool `json:"originCacheControl,omitempty" tf:"origin_cache_control,omitempty"`

	// Whether to generate Cloudflare error pages for issues from the origin server.
	OriginErrorPagePassthru *bool `json:"originErrorPagePassthru,omitempty" tf:"origin_error_page_passthru,omitempty"`

	Overrides *OverridesInitParameters `json:"overrides,omitempty" tf:"overrides,omitempty"`

	// A list of phases to skip the execution of. This option is incompatible with the rulesets option.
	// Available values: "ddos_l4", "ddos_l7", "http_config_settings", "http_custom_errors", "http_log_custom_fields", "http_ratelimit", "http_request_cache_settings", "http_request_dynamic_redirect", "http_request_firewall_custom", "http_request_firewall_managed", "http_request_late_transform", "http_request_origin", "http_request_redirect", "http_request_sanitize", "http_request_sbfm", "http_request_transform", "http_response_compression", "http_response_firewall_managed", "http_response_headers_transform", "magic_transit", "magic_transit_ids_managed", "magic_transit_managed", "magic_transit_ratelimit".
	Phases []*string `json:"phases,omitempty" tf:"phases,omitempty"`

	// The Polish level to configure.
	// Available values: "off", "lossless", "lossy", "webp".
	Polish *string `json:"polish,omitempty" tf:"polish,omitempty"`

	// A list of legacy security products to skip the execution of.
	// Available values: "bic", "hot", "rateLimit", "securityLevel", "uaBlock", "waf", "zoneLockdown".
	Products []*string `json:"products,omitempty" tf:"products,omitempty"`

	RawResponseFields []RawResponseFieldsInitParameters `json:"rawResponseFields,omitempty" tf:"raw_response_fields,omitempty"`

	// A timeout value between two successive read operations to use for your origin server. Historically, the timeout value between two read options from Cloudflare to an origin server is 100 seconds. If you are attempting to reduce HTTP 524 errors because of timeouts from an origin server, try increasing this timeout value.
	ReadTimeout *float64 `json:"readTimeout,omitempty" tf:"read_timeout,omitempty"`

	// The request body buffering mode to configure.
	// Available values: "none", "standard", "full".
	RequestBodyBuffering *string `json:"requestBodyBuffering,omitempty" tf:"request_body_buffering,omitempty"`

	RequestFields []RequestFieldsInitParameters `json:"requestFields,omitempty" tf:"request_fields,omitempty"`

	// Whether Cloudflare should respect strong ETag (entity tag) headers. If false, Cloudflare converts strong ETag headers to weak ETag headers.
	RespectStrongEtags *bool `json:"respectStrongEtags,omitempty" tf:"respect_strong_etags,omitempty"`

	Response *ResponseInitParameters `json:"response,omitempty" tf:"response,omitempty"`

	// The response body buffering mode to configure.
	// Available values: "none", "standard".
	ResponseBodyBuffering *string `json:"responseBodyBuffering,omitempty" tf:"response_body_buffering,omitempty"`

	ResponseFields []ResponseFieldsInitParameters `json:"responseFields,omitempty" tf:"response_fields,omitempty"`

	// Whether to enable Rocket Loader.
	RocketLoader *bool `json:"rocketLoader,omitempty" tf:"rocket_loader,omitempty"`

	// A mapping of ruleset IDs to a list of rule IDs in that ruleset to skip the execution of. This option is incompatible with the ruleset option.
	Rules map[string][]*string `json:"rules,omitempty" tf:"rules,omitempty"`

	// A ruleset to skip the execution of. This option is incompatible with the rulesets option.
	// Available values: "current".
	Ruleset *string `json:"ruleset,omitempty" tf:"ruleset,omitempty"`

	// A list of ruleset IDs to skip the execution of. This option is incompatible with the ruleset and phases options.
	Rulesets []*string `json:"rulesets,omitempty" tf:"rulesets,omitempty"`

	// The SSL level to configure.
	// Available values: "off", "flexible", "full", "strict", "origin_pull".
	SSL *string `json:"ssl,omitempty" tf:"ssl,omitempty"`

	// The Security Level to configure.
	// Available values: "off", "essentially_off", "low", "medium", "high", "under_attack".
	SecurityLevel *string `json:"securityLevel,omitempty" tf:"security_level,omitempty"`

	ServeStale *ServeStaleInitParameters `json:"serveStale,omitempty" tf:"serve_stale,omitempty"`

	// Whether to enable Server-Side Excludes.
	ServerSideExcludes *bool `json:"serverSideExcludes,omitempty" tf:"server_side_excludes,omitempty"`

	Sni *SniInitParameters `json:"sni,omitempty" tf:"sni,omitempty"`

	// The status code to use for the error.
	StatusCode *float64 `json:"statusCode,omitempty" tf:"status_code,omitempty"`

	// Whether to enable Signed Exchanges (SXG).
	Sxg *bool `json:"sxg,omitempty" tf:"sxg,omitempty"`

	TransformedRequestFields []TransformedRequestFieldsInitParameters `json:"transformedRequestFields,omitempty" tf:"transformed_request_fields,omitempty"`

	URI *URIInitParameters `json:"uri,omitempty" tf:"uri,omitempty"`
}

type ActionParametersObservation struct {

	// A list of additional ports that caching should be enabled on.
	AdditionalCacheablePorts []*float64 `json:"additionalCacheablePorts,omitempty" tf:"additional_cacheable_ports,omitempty"`

	Algorithms []AlgorithmsObservation `json:"algorithms,omitempty" tf:"algorithms,omitempty"`

	// The name of a custom asset to serve as the response.
	AssetName *string `json:"assetName,omitempty" tf:"asset_name,omitempty"`

	// Whether to enable Automatic HTTPS Rewrites.
	AutomaticHTTPSRewrites *bool `json:"automaticHttpsRewrites,omitempty" tf:"automatic_https_rewrites,omitempty"`

	Autominify *AutominifyObservation `json:"autominify,omitempty" tf:"autominify,omitempty"`

	// Whether to enable Browser Integrity Check (BIC).
	Bic *bool `json:"bic,omitempty" tf:"bic,omitempty"`

	BrowserTTL *BrowserTTLObservation `json:"browserTtl,omitempty" tf:"browser_ttl,omitempty"`

	// Whether the request's response from the origin is eligible for caching. Caching itself will still depend on the cache control header and your other caching configurations.
	Cache *bool `json:"cache,omitempty" tf:"cache,omitempty"`

	CacheKey *CacheKeyObservation `json:"cacheKey,omitempty" tf:"cache_key,omitempty"`

	CacheReserve *CacheReserveObservation `json:"cacheReserve,omitempty" tf:"cache_reserve,omitempty"`

	// The response content.
	Content *string `json:"content,omitempty" tf:"content,omitempty"`

	// The content type header to set with the error response.
	// Available values: "application/json", "text/html", "text/plain", "text/xml".
	ContentType *string `json:"contentType,omitempty" tf:"content_type,omitempty"`

	CookieFields []CookieFieldsObservation `json:"cookieFields,omitempty" tf:"cookie_fields,omitempty"`

	// Whether to disable Cloudflare Apps.
	DisableApps *bool `json:"disableApps,omitempty" tf:"disable_apps,omitempty"`

	// Whether to disable Real User Monitoring (RUM).
	DisableRum *bool `json:"disableRum,omitempty" tf:"disable_rum,omitempty"`

	// Whether to disable Zaraz.
	DisableZaraz *bool `json:"disableZaraz,omitempty" tf:"disable_zaraz,omitempty"`

	EdgeTTL *EdgeTTLObservation `json:"edgeTtl,omitempty" tf:"edge_ttl,omitempty"`

	// Whether to enable Email Obfuscation.
	EmailObfuscation *bool `json:"emailObfuscation,omitempty" tf:"email_obfuscation,omitempty"`

	// Whether to enable Cloudflare Fonts.
	Fonts *bool `json:"fonts,omitempty" tf:"fonts,omitempty"`

	FromList *FromListObservation `json:"fromList,omitempty" tf:"from_list,omitempty"`

	FromValue *FromValueObservation `json:"fromValue,omitempty" tf:"from_value,omitempty"`

	Headers map[string]HeadersObservation `json:"headers,omitempty" tf:"headers,omitempty"`

	// A value to rewrite the HTTP host header to.
	HostHeader *string `json:"hostHeader,omitempty" tf:"host_header,omitempty"`

	// Whether to enable Hotlink Protection.
	HotlinkProtection *bool `json:"hotlinkProtection,omitempty" tf:"hotlink_protection,omitempty"`

	// The ID of the ruleset to execute.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// A delta to change the score by, which can be either positive or negative.
	Increment *float64 `json:"increment,omitempty" tf:"increment,omitempty"`

	MatchedData *MatchedDataObservation `json:"matchedData,omitempty" tf:"matched_data,omitempty"`

	// Whether to enable Mirage.
	Mirage *bool `json:"mirage,omitempty" tf:"mirage,omitempty"`

	// Whether to enable Opportunistic Encryption.
	OpportunisticEncryption *bool `json:"opportunisticEncryption,omitempty" tf:"opportunistic_encryption,omitempty"`

	Origin *OriginObservation `json:"origin,omitempty" tf:"origin,omitempty"`

	// Whether Cloudflare will aim to strictly adhere to RFC 7234.
	OriginCacheControl *bool `json:"originCacheControl,omitempty" tf:"origin_cache_control,omitempty"`

	// Whether to generate Cloudflare error pages for issues from the origin server.
	OriginErrorPagePassthru *bool `json:"originErrorPagePassthru,omitempty" tf:"origin_error_page_passthru,omitempty"`

	Overrides *OverridesObservation `json:"overrides,omitempty" tf:"overrides,omitempty"`

	// A list of phases to skip the execution of. This option is incompatible with the rulesets option.
	// Available values: "ddos_l4", "ddos_l7", "http_config_settings", "http_custom_errors", "http_log_custom_fields", "http_ratelimit", "http_request_cache_settings", "http_request_dynamic_redirect", "http_request_firewall_custom", "http_request_firewall_managed", "http_request_late_transform", "http_request_origin", "http_request_redirect", "http_request_sanitize", "http_request_sbfm", "http_request_transform", "http_response_compression", "http_response_firewall_managed", "http_response_headers_transform", "magic_transit", "magic_transit_ids_managed", "magic_transit_managed", "magic_transit_ratelimit".
	Phases []*string `json:"phases,omitempty" tf:"phases,omitempty"`

	// The Polish level to configure.
	// Available values: "off", "lossless", "lossy", "webp".
	Polish *string `json:"polish,omitempty" tf:"polish,omitempty"`

	// A list of legacy security products to skip the execution of.
	// Available values: "bic", "hot", "rateLimit", "securityLevel", "uaBlock", "waf", "zoneLockdown".
	Products []*string `json:"products,omitempty" tf:"products,omitempty"`

	RawResponseFields []RawResponseFieldsObservation `json:"rawResponseFields,omitempty" tf:"raw_response_fields,omitempty"`

	// A timeout value between two successive read operations to use for your origin server. Historically, the timeout value between two read options from Cloudflare to an origin server is 100 seconds. If you are attempting to reduce HTTP 524 errors because of timeouts from an origin server, try increasing this timeout value.
	ReadTimeout *float64 `json:"readTimeout,omitempty" tf:"read_timeout,omitempty"`

	// The request body buffering mode to configure.
	// Available values: "none", "standard", "full".
	RequestBodyBuffering *string `json:"requestBodyBuffering,omitempty" tf:"request_body_buffering,omitempty"`

	RequestFields []RequestFieldsObservation `json:"requestFields,omitempty" tf:"request_fields,omitempty"`

	// Whether Cloudflare should respect strong ETag (entity tag) headers. If false, Cloudflare converts strong ETag headers to weak ETag headers.
	RespectStrongEtags *bool `json:"respectStrongEtags,omitempty" tf:"respect_strong_etags,omitempty"`

	Response *ResponseObservation `json:"response,omitempty" tf:"response,omitempty"`

	// The response body buffering mode to configure.
	// Available values: "none", "standard".
	ResponseBodyBuffering *string `json:"responseBodyBuffering,omitempty" tf:"response_body_buffering,omitempty"`

	ResponseFields []ResponseFieldsObservation `json:"responseFields,omitempty" tf:"response_fields,omitempty"`

	// Whether to enable Rocket Loader.
	RocketLoader *bool `json:"rocketLoader,omitempty" tf:"rocket_loader,omitempty"`

	// A mapping of ruleset IDs to a list of rule IDs in that ruleset to skip the execution of. This option is incompatible with the ruleset option.
	Rules map[string][]*string `json:"rules,omitempty" tf:"rules,omitempty"`

	// A ruleset to skip the execution of. This option is incompatible with the rulesets option.
	// Available values: "current".
	Ruleset *string `json:"ruleset,omitempty" tf:"ruleset,omitempty"`

	// A list of ruleset IDs to skip the execution of. This option is incompatible with the ruleset and phases options.
	Rulesets []*string `json:"rulesets,omitempty" tf:"rulesets,omitempty"`

	// The SSL level to configure.
	// Available values: "off", "flexible", "full", "strict", "origin_pull".
	SSL *string `json:"ssl,omitempty" tf:"ssl,omitempty"`

	// The Security Level to configure.
	// Available values: "off", "essentially_off", "low", "medium", "high", "under_attack".
	SecurityLevel *string `json:"securityLevel,omitempty" tf:"security_level,omitempty"`

	ServeStale *ServeStaleObservation `json:"serveStale,omitempty" tf:"serve_stale,omitempty"`

	// Whether to enable Server-Side Excludes.
	ServerSideExcludes *bool `json:"serverSideExcludes,omitempty" tf:"server_side_excludes,omitempty"`

	Sni *SniObservation `json:"sni,omitempty" tf:"sni,omitempty"`

	// The status code to use for the error.
	StatusCode *float64 `json:"statusCode,omitempty" tf:"status_code,omitempty"`

	// Whether to enable Signed Exchanges (SXG).
	Sxg *bool `json:"sxg,omitempty" tf:"sxg,omitempty"`

	TransformedRequestFields []TransformedRequestFieldsObservation `json:"transformedRequestFields,omitempty" tf:"transformed_request_fields,omitempty"`

	URI *URIObservation `json:"uri,omitempty" tf:"uri,omitempty"`
}

type ActionParametersParameters struct {

	// A list of additional ports that caching should be enabled on.
	// +kubebuilder:validation:Optional
	AdditionalCacheablePorts []*float64 `json:"additionalCacheablePorts,omitempty" tf:"additional_cacheable_ports,omitempty"`

	// +kubebuilder:validation:Optional
	Algorithms []AlgorithmsParameters `json:"algorithms,omitempty" tf:"algorithms,omitempty"`

	// The name of a custom asset to serve as the response.
	// +kubebuilder:validation:Optional
	AssetName *string `json:"assetName,omitempty" tf:"asset_name,omitempty"`

	// Whether to enable Automatic HTTPS Rewrites.
	// +kubebuilder:validation:Optional
	AutomaticHTTPSRewrites *bool `json:"automaticHttpsRewrites,omitempty" tf:"automatic_https_rewrites,omitempty"`

	// +kubebuilder:validation:Optional
	Autominify *AutominifyParameters `json:"autominify,omitempty" tf:"autominify,omitempty"`

	// Whether to enable Browser Integrity Check (BIC).
	// +kubebuilder:validation:Optional
	Bic *bool `json:"bic,omitempty" tf:"bic,omitempty"`

	// +kubebuilder:validation:Optional
	BrowserTTL *BrowserTTLParameters `json:"browserTtl,omitempty" tf:"browser_ttl,omitempty"`

	// Whether the request's response from the origin is eligible for caching. Caching itself will still depend on the cache control header and your other caching configurations.
	// +kubebuilder:validation:Optional
	Cache *bool `json:"cache,omitempty" tf:"cache,omitempty"`

	// +kubebuilder:validation:Optional
	CacheKey *CacheKeyParameters `json:"cacheKey,omitempty" tf:"cache_key,omitempty"`

	// +kubebuilder:validation:Optional
	CacheReserve *CacheReserveParameters `json:"cacheReserve,omitempty" tf:"cache_reserve,omitempty"`

	// The response content.
	// +kubebuilder:validation:Optional
	Content *string `json:"content,omitempty" tf:"content,omitempty"`

	// The content type header to set with the error response.
	// Available values: "application/json", "text/html", "text/plain", "text/xml".
	// +kubebuilder:validation:Optional
	ContentType *string `json:"contentType,omitempty" tf:"content_type,omitempty"`

	// +kubebuilder:validation:Optional
	CookieFields []CookieFieldsParameters `json:"cookieFields,omitempty" tf:"cookie_fields,omitempty"`

	// Whether to disable Cloudflare Apps.
	// +kubebuilder:validation:Optional
	DisableApps *bool `json:"disableApps,omitempty" tf:"disable_apps,omitempty"`

	// Whether to disable Real User Monitoring (RUM).
	// +kubebuilder:validation:Optional
	DisableRum *bool `json:"disableRum,omitempty" tf:"disable_rum,omitempty"`

	// Whether to disable Zaraz.
	// +kubebuilder:validation:Optional
	DisableZaraz *bool `json:"disableZaraz,omitempty" tf:"disable_zaraz,omitempty"`

	// +kubebuilder:validation:Optional
	EdgeTTL *EdgeTTLParameters `json:"edgeTtl,omitempty" tf:"edge_ttl,omitempty"`

	// Whether to enable Email Obfuscation.
	// +kubebuilder:validation:Optional
	EmailObfuscation *bool `json:"emailObfuscation,omitempty" tf:"email_obfuscation,omitempty"`

	// Whether to enable Cloudflare Fonts.
	// +kubebuilder:validation:Optional
	Fonts *bool `json:"fonts,omitempty" tf:"fonts,omitempty"`

	// +kubebuilder:validation:Optional
	FromList *FromListParameters `json:"fromList,omitempty" tf:"from_list,omitempty"`

	// +kubebuilder:validation:Optional
	FromValue *FromValueParameters `json:"fromValue,omitempty" tf:"from_value,omitempty"`

	// +kubebuilder:validation:Optional
	Headers map[string]HeadersParameters `json:"headers,omitempty" tf:"headers,omitempty"`

	// A value to rewrite the HTTP host header to.
	// +kubebuilder:validation:Optional
	HostHeader *string `json:"hostHeader,omitempty" tf:"host_header,omitempty"`

	// Whether to enable Hotlink Protection.
	// +kubebuilder:validation:Optional
	HotlinkProtection *bool `json:"hotlinkProtection,omitempty" tf:"hotlink_protection,omitempty"`

	// The ID of the ruleset to execute.
	// +kubebuilder:validation:Optional
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// A delta to change the score by, which can be either positive or negative.
	// +kubebuilder:validation:Optional
	Increment *float64 `json:"increment,omitempty" tf:"increment,omitempty"`

	// +kubebuilder:validation:Optional
	MatchedData *MatchedDataParameters `json:"matchedData,omitempty" tf:"matched_data,omitempty"`

	// Whether to enable Mirage.
	// +kubebuilder:validation:Optional
	Mirage *bool `json:"mirage,omitempty" tf:"mirage,omitempty"`

	// Whether to enable Opportunistic Encryption.
	// +kubebuilder:validation:Optional
	OpportunisticEncryption *bool `json:"opportunisticEncryption,omitempty" tf:"opportunistic_encryption,omitempty"`

	// +kubebuilder:validation:Optional
	Origin *OriginParameters `json:"origin,omitempty" tf:"origin,omitempty"`

	// Whether Cloudflare will aim to strictly adhere to RFC 7234.
	// +kubebuilder:validation:Optional
	OriginCacheControl *bool `json:"originCacheControl,omitempty" tf:"origin_cache_control,omitempty"`

	// Whether to generate Cloudflare error pages for issues from the origin server.
	// +kubebuilder:validation:Optional
	OriginErrorPagePassthru *bool `json:"originErrorPagePassthru,omitempty" tf:"origin_error_page_passthru,omitempty"`

	// +kubebuilder:validation:Optional
	Overrides *OverridesParameters `json:"overrides,omitempty" tf:"overrides,omitempty"`

	// A list of phases to skip the execution of. This option is incompatible with the rulesets option.
	// Available values: "ddos_l4", "ddos_l7", "http_config_settings", "http_custom_errors", "http_log_custom_fields", "http_ratelimit", "http_request_cache_settings", "http_request_dynamic_redirect", "http_request_firewall_custom", "http_request_firewall_managed", "http_request_late_transform", "http_request_origin", "http_request_redirect", "http_request_sanitize", "http_request_sbfm", "http_request_transform", "http_response_compression", "http_response_firewall_managed", "http_response_headers_transform", "magic_transit", "magic_transit_ids_managed", "magic_transit_managed", "magic_transit_ratelimit".
	// +kubebuilder:validation:Optional
	Phases []*string `json:"phases,omitempty" tf:"phases,omitempty"`

	// The Polish level to configure.
	// Available values: "off", "lossless", "lossy", "webp".
	// +kubebuilder:validation:Optional
	Polish *string `json:"polish,omitempty" tf:"polish,omitempty"`

	// A list of legacy security products to skip the execution of.
	// Available values: "bic", "hot", "rateLimit", "securityLevel", "uaBlock", "waf", "zoneLockdown".
	// +kubebuilder:validation:Optional
	Products []*string `json:"products,omitempty" tf:"products,omitempty"`

	// +kubebuilder:validation:Optional
	RawResponseFields []RawResponseFieldsParameters `json:"rawResponseFields,omitempty" tf:"raw_response_fields,omitempty"`

	// A timeout value between two successive read operations to use for your origin server. Historically, the timeout value between two read options from Cloudflare to an origin server is 100 seconds. If you are attempting to reduce HTTP 524 errors because of timeouts from an origin server, try increasing this timeout value.
	// +kubebuilder:validation:Optional
	ReadTimeout *float64 `json:"readTimeout,omitempty" tf:"read_timeout,omitempty"`

	// The request body buffering mode to configure.
	// Available values: "none", "standard", "full".
	// +kubebuilder:validation:Optional
	RequestBodyBuffering *string `json:"requestBodyBuffering,omitempty" tf:"request_body_buffering,omitempty"`

	// +kubebuilder:validation:Optional
	RequestFields []RequestFieldsParameters `json:"requestFields,omitempty" tf:"request_fields,omitempty"`

	// Whether Cloudflare should respect strong ETag (entity tag) headers. If false, Cloudflare converts strong ETag headers to weak ETag headers.
	// +kubebuilder:validation:Optional
	RespectStrongEtags *bool `json:"respectStrongEtags,omitempty" tf:"respect_strong_etags,omitempty"`

	// +kubebuilder:validation:Optional
	Response *ResponseParameters `json:"response,omitempty" tf:"response,omitempty"`

	// The response body buffering mode to configure.
	// Available values: "none", "standard".
	// +kubebuilder:validation:Optional
	ResponseBodyBuffering *string `json:"responseBodyBuffering,omitempty" tf:"response_body_buffering,omitempty"`

	// +kubebuilder:validation:Optional
	ResponseFields []ResponseFieldsParameters `json:"responseFields,omitempty" tf:"response_fields,omitempty"`

	// Whether to enable Rocket Loader.
	// +kubebuilder:validation:Optional
	RocketLoader *bool `json:"rocketLoader,omitempty" tf:"rocket_loader,omitempty"`

	// A mapping of ruleset IDs to a list of rule IDs in that ruleset to skip the execution of. This option is incompatible with the ruleset option.
	// +kubebuilder:validation:Optional
	Rules map[string][]*string `json:"rules,omitempty" tf:"rules,omitempty"`

	// A ruleset to skip the execution of. This option is incompatible with the rulesets option.
	// Available values: "current".
	// +kubebuilder:validation:Optional
	Ruleset *string `json:"ruleset,omitempty" tf:"ruleset,omitempty"`

	// A list of ruleset IDs to skip the execution of. This option is incompatible with the ruleset and phases options.
	// +kubebuilder:validation:Optional
	Rulesets []*string `json:"rulesets,omitempty" tf:"rulesets,omitempty"`

	// The SSL level to configure.
	// Available values: "off", "flexible", "full", "strict", "origin_pull".
	// +kubebuilder:validation:Optional
	SSL *string `json:"ssl,omitempty" tf:"ssl,omitempty"`

	// The Security Level to configure.
	// Available values: "off", "essentially_off", "low", "medium", "high", "under_attack".
	// +kubebuilder:validation:Optional
	SecurityLevel *string `json:"securityLevel,omitempty" tf:"security_level,omitempty"`

	// +kubebuilder:validation:Optional
	ServeStale *ServeStaleParameters `json:"serveStale,omitempty" tf:"serve_stale,omitempty"`

	// Whether to enable Server-Side Excludes.
	// +kubebuilder:validation:Optional
	ServerSideExcludes *bool `json:"serverSideExcludes,omitempty" tf:"server_side_excludes,omitempty"`

	// +kubebuilder:validation:Optional
	Sni *SniParameters `json:"sni,omitempty" tf:"sni,omitempty"`

	// The status code to use for the error.
	// +kubebuilder:validation:Optional
	StatusCode *float64 `json:"statusCode,omitempty" tf:"status_code,omitempty"`

	// Whether to enable Signed Exchanges (SXG).
	// +kubebuilder:validation:Optional
	Sxg *bool `json:"sxg,omitempty" tf:"sxg,omitempty"`

	// +kubebuilder:validation:Optional
	TransformedRequestFields []TransformedRequestFieldsParameters `json:"transformedRequestFields,omitempty" tf:"transformed_request_fields,omitempty"`

	// +kubebuilder:validation:Optional
	URI *URIParameters `json:"uri,omitempty" tf:"uri,omitempty"`
}

type AlgorithmsInitParameters struct {

	// Name of the compression algorithm to enable.
	// Available values: "none", "auto", "default", "gzip", "brotli", "zstd".
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type AlgorithmsObservation struct {

	// Name of the compression algorithm to enable.
	// Available values: "none", "auto", "default", "gzip", "brotli", "zstd".
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type AlgorithmsParameters struct {

	// Name of the compression algorithm to enable.
	// Available values: "none", "auto", "default", "gzip", "brotli", "zstd".
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type AutominifyInitParameters struct {

	// Whether to minify CSS files.
	CSS *bool `json:"css,omitempty" tf:"css,omitempty"`

	// Whether to minify HTML files.
	HTML *bool `json:"html,omitempty" tf:"html,omitempty"`

	// Whether to minify JavaScript files.
	Js *bool `json:"js,omitempty" tf:"js,omitempty"`
}

type AutominifyObservation struct {

	// Whether to minify CSS files.
	CSS *bool `json:"css,omitempty" tf:"css,omitempty"`

	// Whether to minify HTML files.
	HTML *bool `json:"html,omitempty" tf:"html,omitempty"`

	// Whether to minify JavaScript files.
	Js *bool `json:"js,omitempty" tf:"js,omitempty"`
}

type AutominifyParameters struct {

	// Whether to minify CSS files.
	// +kubebuilder:validation:Optional
	CSS *bool `json:"css,omitempty" tf:"css,omitempty"`

	// Whether to minify HTML files.
	// +kubebuilder:validation:Optional
	HTML *bool `json:"html,omitempty" tf:"html,omitempty"`

	// Whether to minify JavaScript files.
	// +kubebuilder:validation:Optional
	Js *bool `json:"js,omitempty" tf:"js,omitempty"`
}

type BrowserTTLInitParameters struct {

	// The browser TTL (in seconds) if you choose the "override_origin" mode.
	Default *float64 `json:"default,omitempty" tf:"default,omitempty"`

	// The browser TTL mode.
	// Available values: "respect_origin", "bypass_by_default", "override_origin", "bypass".
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`
}

type BrowserTTLObservation struct {

	// The browser TTL (in seconds) if you choose the "override_origin" mode.
	Default *float64 `json:"default,omitempty" tf:"default,omitempty"`

	// The browser TTL mode.
	// Available values: "respect_origin", "bypass_by_default", "override_origin", "bypass".
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`
}

type BrowserTTLParameters struct {

	// The browser TTL (in seconds) if you choose the "override_origin" mode.
	// +kubebuilder:validation:Optional
	Default *float64 `json:"default,omitempty" tf:"default,omitempty"`

	// The browser TTL mode.
	// Available values: "respect_origin", "bypass_by_default", "override_origin", "bypass".
	// +kubebuilder:validation:Optional
	Mode *string `json:"mode" tf:"mode,omitempty"`
}

type CacheKeyInitParameters struct {

	// Whether to separate cached content based on the visitor's device type.
	CacheByDeviceType *bool `json:"cacheByDeviceType,omitempty" tf:"cache_by_device_type,omitempty"`

	// Whether to protect from web cache deception attacks, while allowing static assets to be cached.
	CacheDeceptionArmor *bool `json:"cacheDeceptionArmor,omitempty" tf:"cache_deception_armor,omitempty"`

	CustomKey *CustomKeyInitParameters `json:"customKey,omitempty" tf:"custom_key,omitempty"`

	// Whether to treat requests with the same query parameters the same, regardless of the order those query parameters are in.
	IgnoreQueryStringsOrder *bool `json:"ignoreQueryStringsOrder,omitempty" tf:"ignore_query_strings_order,omitempty"`
}

type CacheKeyObservation struct {

	// Whether to separate cached content based on the visitor's device type.
	CacheByDeviceType *bool `json:"cacheByDeviceType,omitempty" tf:"cache_by_device_type,omitempty"`

	// Whether to protect from web cache deception attacks, while allowing static assets to be cached.
	CacheDeceptionArmor *bool `json:"cacheDeceptionArmor,omitempty" tf:"cache_deception_armor,omitempty"`

	CustomKey *CustomKeyObservation `json:"customKey,omitempty" tf:"custom_key,omitempty"`

	// Whether to treat requests with the same query parameters the same, regardless of the order those query parameters are in.
	IgnoreQueryStringsOrder *bool `json:"ignoreQueryStringsOrder,omitempty" tf:"ignore_query_strings_order,omitempty"`
}

type CacheKeyParameters struct {

	// Whether to separate cached content based on the visitor's device type.
	// +kubebuilder:validation:Optional
	CacheByDeviceType *bool `json:"cacheByDeviceType,omitempty" tf:"cache_by_device_type,omitempty"`

	// Whether to protect from web cache deception attacks, while allowing static assets to be cached.
	// +kubebuilder:validation:Optional
	CacheDeceptionArmor *bool `json:"cacheDeceptionArmor,omitempty" tf:"cache_deception_armor,omitempty"`

	// +kubebuilder:validation:Optional
	CustomKey *CustomKeyParameters `json:"customKey,omitempty" tf:"custom_key,omitempty"`

	// Whether to treat requests with the same query parameters the same, regardless of the order those query parameters are in.
	// +kubebuilder:validation:Optional
	IgnoreQueryStringsOrder *bool `json:"ignoreQueryStringsOrder,omitempty" tf:"ignore_query_strings_order,omitempty"`
}

type CacheReserveInitParameters struct {

	// Whether Cache Reserve is enabled. If this is true and a request meets eligibility criteria, Cloudflare will write the resource to Cache Reserve.
	Eligible *bool `json:"eligible,omitempty" tf:"eligible,omitempty"`

	// The minimum file size eligible for storage in Cache Reserve.
	MinimumFileSize *float64 `json:"minimumFileSize,omitempty" tf:"minimum_file_size,omitempty"`
}

type CacheReserveObservation struct {

	// Whether Cache Reserve is enabled. If this is true and a request meets eligibility criteria, Cloudflare will write the resource to Cache Reserve.
	Eligible *bool `json:"eligible,omitempty" tf:"eligible,omitempty"`

	// The minimum file size eligible for storage in Cache Reserve.
	MinimumFileSize *float64 `json:"minimumFileSize,omitempty" tf:"minimum_file_size,omitempty"`
}

type CacheReserveParameters struct {

	// Whether Cache Reserve is enabled. If this is true and a request meets eligibility criteria, Cloudflare will write the resource to Cache Reserve.
	// +kubebuilder:validation:Optional
	Eligible *bool `json:"eligible" tf:"eligible,omitempty"`

	// The minimum file size eligible for storage in Cache Reserve.
	// +kubebuilder:validation:Optional
	MinimumFileSize *float64 `json:"minimumFileSize,omitempty" tf:"minimum_file_size,omitempty"`
}

type CategoriesInitParameters struct {

	// The action to override rules in the category with.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// The name of the category to override.
	Category *string `json:"category,omitempty" tf:"category,omitempty"`

	// Whether to enable execution of rules in the category.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The sensitivity level to use for rules in the category. This option is only applicable for DDoS phases.
	// Available values: "default", "medium", "low", "eoff".
	SensitivityLevel *string `json:"sensitivityLevel,omitempty" tf:"sensitivity_level,omitempty"`
}

type CategoriesObservation struct {

	// The action to override rules in the category with.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// The name of the category to override.
	Category *string `json:"category,omitempty" tf:"category,omitempty"`

	// Whether to enable execution of rules in the category.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The sensitivity level to use for rules in the category. This option is only applicable for DDoS phases.
	// Available values: "default", "medium", "low", "eoff".
	SensitivityLevel *string `json:"sensitivityLevel,omitempty" tf:"sensitivity_level,omitempty"`
}

type CategoriesParameters struct {

	// The action to override rules in the category with.
	// +kubebuilder:validation:Optional
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// The name of the category to override.
	// +kubebuilder:validation:Optional
	Category *string `json:"category" tf:"category,omitempty"`

	// Whether to enable execution of rules in the category.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The sensitivity level to use for rules in the category. This option is only applicable for DDoS phases.
	// Available values: "default", "medium", "low", "eoff".
	// +kubebuilder:validation:Optional
	SensitivityLevel *string `json:"sensitivityLevel,omitempty" tf:"sensitivity_level,omitempty"`
}

type CookieFieldsInitParameters struct {

	// The name of the cookie.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type CookieFieldsObservation struct {

	// The name of the cookie.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type CookieFieldsParameters struct {

	// The name of the cookie.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`
}

type CookieInitParameters struct {

	// A list of cookies to check for the presence of. The presence of these cookies is included in the cache key.
	CheckPresence []*string `json:"checkPresence,omitempty" tf:"check_presence,omitempty"`

	// A list of cookies to include in the cache key.
	Include []*string `json:"include,omitempty" tf:"include,omitempty"`
}

type CookieObservation struct {

	// A list of cookies to check for the presence of. The presence of these cookies is included in the cache key.
	CheckPresence []*string `json:"checkPresence,omitempty" tf:"check_presence,omitempty"`

	// A list of cookies to include in the cache key.
	Include []*string `json:"include,omitempty" tf:"include,omitempty"`
}

type CookieParameters struct {

	// A list of cookies to check for the presence of. The presence of these cookies is included in the cache key.
	// +kubebuilder:validation:Optional
	CheckPresence []*string `json:"checkPresence,omitempty" tf:"check_presence,omitempty"`

	// A list of cookies to include in the cache key.
	// +kubebuilder:validation:Optional
	Include []*string `json:"include,omitempty" tf:"include,omitempty"`
}

type CustomKeyInitParameters struct {
	Cookie *CookieInitParameters `json:"cookie,omitempty" tf:"cookie,omitempty"`

	Header *HeaderInitParameters `json:"header,omitempty" tf:"header,omitempty"`

	Host *HostInitParameters `json:"host,omitempty" tf:"host,omitempty"`

	QueryString *QueryStringInitParameters `json:"queryString,omitempty" tf:"query_string,omitempty"`

	User *UserInitParameters `json:"user,omitempty" tf:"user,omitempty"`
}

type CustomKeyObservation struct {
	Cookie *CookieObservation `json:"cookie,omitempty" tf:"cookie,omitempty"`

	Header *HeaderObservation `json:"header,omitempty" tf:"header,omitempty"`

	Host *HostObservation `json:"host,omitempty" tf:"host,omitempty"`

	QueryString *QueryStringObservation `json:"queryString,omitempty" tf:"query_string,omitempty"`

	User *UserObservation `json:"user,omitempty" tf:"user,omitempty"`
}

type CustomKeyParameters struct {

	// +kubebuilder:validation:Optional
	Cookie *CookieParameters `json:"cookie,omitempty" tf:"cookie,omitempty"`

	// +kubebuilder:validation:Optional
	Header *HeaderParameters `json:"header,omitempty" tf:"header,omitempty"`

	// +kubebuilder:validation:Optional
	Host *HostParameters `json:"host,omitempty" tf:"host,omitempty"`

	// +kubebuilder:validation:Optional
	QueryString *QueryStringParameters `json:"queryString,omitempty" tf:"query_string,omitempty"`

	// +kubebuilder:validation:Optional
	User *UserParameters `json:"user,omitempty" tf:"user,omitempty"`
}

type EdgeTTLInitParameters struct {

	// The edge TTL (in seconds) if you choose the "override_origin" mode.
	Default *float64 `json:"default,omitempty" tf:"default,omitempty"`

	// The edge TTL mode.
	// Available values: "respect_origin", "bypass_by_default", "override_origin".
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	StatusCodeTTL []StatusCodeTTLInitParameters `json:"statusCodeTtl,omitempty" tf:"status_code_ttl,omitempty"`
}

type EdgeTTLObservation struct {

	// The edge TTL (in seconds) if you choose the "override_origin" mode.
	Default *float64 `json:"default,omitempty" tf:"default,omitempty"`

	// The edge TTL mode.
	// Available values: "respect_origin", "bypass_by_default", "override_origin".
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	StatusCodeTTL []StatusCodeTTLObservation `json:"statusCodeTtl,omitempty" tf:"status_code_ttl,omitempty"`
}

type EdgeTTLParameters struct {

	// The edge TTL (in seconds) if you choose the "override_origin" mode.
	// +kubebuilder:validation:Optional
	Default *float64 `json:"default,omitempty" tf:"default,omitempty"`

	// The edge TTL mode.
	// Available values: "respect_origin", "bypass_by_default", "override_origin".
	// +kubebuilder:validation:Optional
	Mode *string `json:"mode" tf:"mode,omitempty"`

	// +kubebuilder:validation:Optional
	StatusCodeTTL []StatusCodeTTLParameters `json:"statusCodeTtl,omitempty" tf:"status_code_ttl,omitempty"`
}

type ExcludeInitParameters struct {

	// Whether to exclude all query string parameters from the cache key.
	All *bool `json:"all,omitempty" tf:"all,omitempty"`

	// A list of query string parameters to exclude from the cache key.
	List []*string `json:"list,omitempty" tf:"list,omitempty"`
}

type ExcludeObservation struct {

	// Whether to exclude all query string parameters from the cache key.
	All *bool `json:"all,omitempty" tf:"all,omitempty"`

	// A list of query string parameters to exclude from the cache key.
	List []*string `json:"list,omitempty" tf:"list,omitempty"`
}

type ExcludeParameters struct {

	// Whether to exclude all query string parameters from the cache key.
	// +kubebuilder:validation:Optional
	All *bool `json:"all,omitempty" tf:"all,omitempty"`

	// A list of query string parameters to exclude from the cache key.
	// +kubebuilder:validation:Optional
	List []*string `json:"list,omitempty" tf:"list,omitempty"`
}

type ExposedCredentialCheckInitParameters struct {

	// An expression that selects the password used in the credentials check.
	PasswordExpression *string `json:"passwordExpression,omitempty" tf:"password_expression,omitempty"`

	// An expression that selects the user ID used in the credentials check.
	UsernameExpression *string `json:"usernameExpression,omitempty" tf:"username_expression,omitempty"`
}

type ExposedCredentialCheckObservation struct {

	// An expression that selects the password used in the credentials check.
	PasswordExpression *string `json:"passwordExpression,omitempty" tf:"password_expression,omitempty"`

	// An expression that selects the user ID used in the credentials check.
	UsernameExpression *string `json:"usernameExpression,omitempty" tf:"username_expression,omitempty"`
}

type ExposedCredentialCheckParameters struct {

	// An expression that selects the password used in the credentials check.
	// +kubebuilder:validation:Optional
	PasswordExpression *string `json:"passwordExpression" tf:"password_expression,omitempty"`

	// An expression that selects the user ID used in the credentials check.
	// +kubebuilder:validation:Optional
	UsernameExpression *string `json:"usernameExpression" tf:"username_expression,omitempty"`
}

type FromListInitParameters struct {

	// An expression that evaluates to the list lookup key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The name of the list to match against.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type FromListObservation struct {

	// An expression that evaluates to the list lookup key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The name of the list to match against.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type FromListParameters struct {

	// An expression that evaluates to the list lookup key.
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// The name of the list to match against.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`
}

type FromValueInitParameters struct {

	// Whether to keep the query string of the original request.
	PreserveQueryString *bool `json:"preserveQueryString,omitempty" tf:"preserve_query_string,omitempty"`

	// The status code to use for the redirect.
	StatusCode *float64 `json:"statusCode,omitempty" tf:"status_code,omitempty"`

	TargetURL *TargetURLInitParameters `json:"targetUrl,omitempty" tf:"target_url,omitempty"`
}

type FromValueObservation struct {

	// Whether to keep the query string of the original request.
	PreserveQueryString *bool `json:"preserveQueryString,omitempty" tf:"preserve_query_string,omitempty"`

	// The status code to use for the redirect.
	StatusCode *float64 `json:"statusCode,omitempty" tf:"status_code,omitempty"`

	TargetURL *TargetURLObservation `json:"targetUrl,omitempty" tf:"target_url,omitempty"`
}

type FromValueParameters struct {

	// Whether to keep the query string of the original request.
	// +kubebuilder:validation:Optional
	PreserveQueryString *bool `json:"preserveQueryString,omitempty" tf:"preserve_query_string,omitempty"`

	// The status code to use for the redirect.
	// +kubebuilder:validation:Optional
	StatusCode *float64 `json:"statusCode,omitempty" tf:"status_code,omitempty"`

	// +kubebuilder:validation:Optional
	TargetURL *TargetURLParameters `json:"targetUrl" tf:"target_url,omitempty"`
}

type HeaderInitParameters struct {

	// A list of headers to check for the presence of. The presence of these headers is included in the cache key.
	CheckPresence []*string `json:"checkPresence,omitempty" tf:"check_presence,omitempty"`

	// A mapping of header names to a list of values. If a header is present in the request and contains any of the values provided, its value is included in the cache key.
	Contains map[string][]*string `json:"contains,omitempty" tf:"contains,omitempty"`

	// Whether to exclude the origin header in the cache key.
	ExcludeOrigin *bool `json:"excludeOrigin,omitempty" tf:"exclude_origin,omitempty"`

	// A list of headers to include in the cache key.
	Include []*string `json:"include,omitempty" tf:"include,omitempty"`
}

type HeaderObservation struct {

	// A list of headers to check for the presence of. The presence of these headers is included in the cache key.
	CheckPresence []*string `json:"checkPresence,omitempty" tf:"check_presence,omitempty"`

	// A mapping of header names to a list of values. If a header is present in the request and contains any of the values provided, its value is included in the cache key.
	Contains map[string][]*string `json:"contains,omitempty" tf:"contains,omitempty"`

	// Whether to exclude the origin header in the cache key.
	ExcludeOrigin *bool `json:"excludeOrigin,omitempty" tf:"exclude_origin,omitempty"`

	// A list of headers to include in the cache key.
	Include []*string `json:"include,omitempty" tf:"include,omitempty"`
}

type HeaderParameters struct {

	// A list of headers to check for the presence of. The presence of these headers is included in the cache key.
	// +kubebuilder:validation:Optional
	CheckPresence []*string `json:"checkPresence,omitempty" tf:"check_presence,omitempty"`

	// A mapping of header names to a list of values. If a header is present in the request and contains any of the values provided, its value is included in the cache key.
	// +kubebuilder:validation:Optional
	Contains map[string][]*string `json:"contains,omitempty" tf:"contains,omitempty"`

	// Whether to exclude the origin header in the cache key.
	// +kubebuilder:validation:Optional
	ExcludeOrigin *bool `json:"excludeOrigin,omitempty" tf:"exclude_origin,omitempty"`

	// A list of headers to include in the cache key.
	// +kubebuilder:validation:Optional
	Include []*string `json:"include,omitempty" tf:"include,omitempty"`
}

type HeadersInitParameters struct {

	// An expression that evaluates to a value for the header.
	Expression *string `json:"expression,omitempty" tf:"expression,omitempty"`

	// The operation to perform on the header.
	// Available values: "add", "set", "remove".
	Operation *string `json:"operation,omitempty" tf:"operation,omitempty"`

	// A static value for the header.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type HeadersObservation struct {

	// An expression that evaluates to a value for the header.
	Expression *string `json:"expression,omitempty" tf:"expression,omitempty"`

	// The operation to perform on the header.
	// Available values: "add", "set", "remove".
	Operation *string `json:"operation,omitempty" tf:"operation,omitempty"`

	// A static value for the header.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type HeadersParameters struct {

	// An expression that evaluates to a value for the header.
	// +kubebuilder:validation:Optional
	Expression *string `json:"expression,omitempty" tf:"expression,omitempty"`

	// The operation to perform on the header.
	// Available values: "add", "set", "remove".
	// +kubebuilder:validation:Optional
	Operation *string `json:"operation" tf:"operation,omitempty"`

	// A static value for the header.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type HostInitParameters struct {

	// Whether to use the resolved host in the cache key.
	Resolved *bool `json:"resolved,omitempty" tf:"resolved,omitempty"`
}

type HostObservation struct {

	// Whether to use the resolved host in the cache key.
	Resolved *bool `json:"resolved,omitempty" tf:"resolved,omitempty"`
}

type HostParameters struct {

	// Whether to use the resolved host in the cache key.
	// +kubebuilder:validation:Optional
	Resolved *bool `json:"resolved,omitempty" tf:"resolved,omitempty"`
}

type IncludeInitParameters struct {

	// Whether to include all query string parameters in the cache key.
	All *bool `json:"all,omitempty" tf:"all,omitempty"`

	// A list of query string parameters to include in the cache key.
	List []*string `json:"list,omitempty" tf:"list,omitempty"`
}

type IncludeObservation struct {

	// Whether to include all query string parameters in the cache key.
	All *bool `json:"all,omitempty" tf:"all,omitempty"`

	// A list of query string parameters to include in the cache key.
	List []*string `json:"list,omitempty" tf:"list,omitempty"`
}

type IncludeParameters struct {

	// Whether to include all query string parameters in the cache key.
	// +kubebuilder:validation:Optional
	All *bool `json:"all,omitempty" tf:"all,omitempty"`

	// A list of query string parameters to include in the cache key.
	// +kubebuilder:validation:Optional
	List []*string `json:"list,omitempty" tf:"list,omitempty"`
}

type LoggingInitParameters struct {

	// Whether to generate a log when the rule matches.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type LoggingObservation struct {

	// Whether to generate a log when the rule matches.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type LoggingParameters struct {

	// Whether to generate a log when the rule matches.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type MatchedDataInitParameters struct {

	// The public key to encrypt matched data logs with.
	PublicKey *string `json:"publicKey,omitempty" tf:"public_key,omitempty"`
}

type MatchedDataObservation struct {

	// The public key to encrypt matched data logs with.
	PublicKey *string `json:"publicKey,omitempty" tf:"public_key,omitempty"`
}

type MatchedDataParameters struct {

	// The public key to encrypt matched data logs with.
	// +kubebuilder:validation:Optional
	PublicKey *string `json:"publicKey" tf:"public_key,omitempty"`
}

type OriginInitParameters struct {

	// A resolved host to route to.
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// A destination port to route to.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`
}

type OriginObservation struct {

	// A resolved host to route to.
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// A destination port to route to.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`
}

type OriginParameters struct {

	// A resolved host to route to.
	// +kubebuilder:validation:Optional
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// A destination port to route to.
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`
}

type OverridesInitParameters struct {

	// An action to override all rules with. This option has lower precedence than rule and category overrides.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	Categories []CategoriesInitParameters `json:"categories,omitempty" tf:"categories,omitempty"`

	// Whether to enable execution of all rules. This option has lower precedence than rule and category overrides.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	Rules []OverridesRulesInitParameters `json:"rules,omitempty" tf:"rules,omitempty"`

	// A sensitivity level to set for all rules. This option has lower precedence than rule and category overrides and is only applicable for DDoS phases.
	// Available values: "default", "medium", "low", "eoff".
	SensitivityLevel *string `json:"sensitivityLevel,omitempty" tf:"sensitivity_level,omitempty"`
}

type OverridesObservation struct {

	// An action to override all rules with. This option has lower precedence than rule and category overrides.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	Categories []CategoriesObservation `json:"categories,omitempty" tf:"categories,omitempty"`

	// Whether to enable execution of all rules. This option has lower precedence than rule and category overrides.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	Rules []OverridesRulesObservation `json:"rules,omitempty" tf:"rules,omitempty"`

	// A sensitivity level to set for all rules. This option has lower precedence than rule and category overrides and is only applicable for DDoS phases.
	// Available values: "default", "medium", "low", "eoff".
	SensitivityLevel *string `json:"sensitivityLevel,omitempty" tf:"sensitivity_level,omitempty"`
}

type OverridesParameters struct {

	// An action to override all rules with. This option has lower precedence than rule and category overrides.
	// +kubebuilder:validation:Optional
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// +kubebuilder:validation:Optional
	Categories []CategoriesParameters `json:"categories,omitempty" tf:"categories,omitempty"`

	// Whether to enable execution of all rules. This option has lower precedence than rule and category overrides.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Optional
	Rules []OverridesRulesParameters `json:"rules,omitempty" tf:"rules,omitempty"`

	// A sensitivity level to set for all rules. This option has lower precedence than rule and category overrides and is only applicable for DDoS phases.
	// Available values: "default", "medium", "low", "eoff".
	// +kubebuilder:validation:Optional
	SensitivityLevel *string `json:"sensitivityLevel,omitempty" tf:"sensitivity_level,omitempty"`
}

type OverridesRulesInitParameters struct {

	// The action to override the rule with.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// Whether to enable execution of the rule.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The ID of the rule to override.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The score threshold to use for the rule.
	ScoreThreshold *float64 `json:"scoreThreshold,omitempty" tf:"score_threshold,omitempty"`

	// The sensitivity level to use for the rule. This option is only applicable for DDoS phases.
	// Available values: "default", "medium", "low", "eoff".
	SensitivityLevel *string `json:"sensitivityLevel,omitempty" tf:"sensitivity_level,omitempty"`
}

type OverridesRulesObservation struct {

	// The action to override the rule with.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// Whether to enable execution of the rule.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The ID of the rule to override.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The score threshold to use for the rule.
	ScoreThreshold *float64 `json:"scoreThreshold,omitempty" tf:"score_threshold,omitempty"`

	// The sensitivity level to use for the rule. This option is only applicable for DDoS phases.
	// Available values: "default", "medium", "low", "eoff".
	SensitivityLevel *string `json:"sensitivityLevel,omitempty" tf:"sensitivity_level,omitempty"`
}

type OverridesRulesParameters struct {

	// The action to override the rule with.
	// +kubebuilder:validation:Optional
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// Whether to enable execution of the rule.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The ID of the rule to override.
	// +kubebuilder:validation:Optional
	ID *string `json:"id" tf:"id,omitempty"`

	// The score threshold to use for the rule.
	// +kubebuilder:validation:Optional
	ScoreThreshold *float64 `json:"scoreThreshold,omitempty" tf:"score_threshold,omitempty"`

	// The sensitivity level to use for the rule. This option is only applicable for DDoS phases.
	// Available values: "default", "medium", "low", "eoff".
	// +kubebuilder:validation:Optional
	SensitivityLevel *string `json:"sensitivityLevel,omitempty" tf:"sensitivity_level,omitempty"`
}

type PathInitParameters struct {

	// An expression that evaluates to a value to rewrite the URI path to.
	Expression *string `json:"expression,omitempty" tf:"expression,omitempty"`

	// A value to rewrite the URI path to.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type PathObservation struct {

	// An expression that evaluates to a value to rewrite the URI path to.
	Expression *string `json:"expression,omitempty" tf:"expression,omitempty"`

	// A value to rewrite the URI path to.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type PathParameters struct {

	// An expression that evaluates to a value to rewrite the URI path to.
	// +kubebuilder:validation:Optional
	Expression *string `json:"expression,omitempty" tf:"expression,omitempty"`

	// A value to rewrite the URI path to.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type QueryInitParameters struct {

	// An expression that evaluates to a value to rewrite the URI query to.
	Expression *string `json:"expression,omitempty" tf:"expression,omitempty"`

	// A value to rewrite the URI query to.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type QueryObservation struct {

	// An expression that evaluates to a value to rewrite the URI query to.
	Expression *string `json:"expression,omitempty" tf:"expression,omitempty"`

	// A value to rewrite the URI query to.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type QueryParameters struct {

	// An expression that evaluates to a value to rewrite the URI query to.
	// +kubebuilder:validation:Optional
	Expression *string `json:"expression,omitempty" tf:"expression,omitempty"`

	// A value to rewrite the URI query to.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type QueryStringInitParameters struct {
	Exclude *ExcludeInitParameters `json:"exclude,omitempty" tf:"exclude,omitempty"`

	Include *IncludeInitParameters `json:"include,omitempty" tf:"include,omitempty"`
}

type QueryStringObservation struct {
	Exclude *ExcludeObservation `json:"exclude,omitempty" tf:"exclude,omitempty"`

	Include *IncludeObservation `json:"include,omitempty" tf:"include,omitempty"`
}

type QueryStringParameters struct {

	// +kubebuilder:validation:Optional
	Exclude *ExcludeParameters `json:"exclude,omitempty" tf:"exclude,omitempty"`

	// +kubebuilder:validation:Optional
	Include *IncludeParameters `json:"include,omitempty" tf:"include,omitempty"`
}

type RatelimitInitParameters struct {

	// Characteristics of the request on which the rate limit counter will be incremented.
	Characteristics []*string `json:"characteristics,omitempty" tf:"characteristics,omitempty"`

	// An expression that defines when the rate limit counter should be incremented. It defaults to the same as the rule's expression.
	CountingExpression *string `json:"countingExpression,omitempty" tf:"counting_expression,omitempty"`

	// Period of time in seconds after which the action will be disabled following its first execution.
	MitigationTimeout *float64 `json:"mitigationTimeout,omitempty" tf:"mitigation_timeout,omitempty"`

	// Period in seconds over which the counter is being incremented.
	Period *float64 `json:"period,omitempty" tf:"period,omitempty"`

	// The threshold of requests per period after which the action will be executed for the first time.
	RequestsPerPeriod *float64 `json:"requestsPerPeriod,omitempty" tf:"requests_per_period,omitempty"`

	// Whether counting is only performed when an origin is reached.
	RequestsToOrigin *bool `json:"requestsToOrigin,omitempty" tf:"requests_to_origin,omitempty"`

	// The score threshold per period for which the action will be executed the first time.
	ScorePerPeriod *float64 `json:"scorePerPeriod,omitempty" tf:"score_per_period,omitempty"`

	// A response header name provided by the origin, which contains the score to increment rate limit counter with.
	ScoreResponseHeaderName *string `json:"scoreResponseHeaderName,omitempty" tf:"score_response_header_name,omitempty"`
}

type RatelimitObservation struct {

	// Characteristics of the request on which the rate limit counter will be incremented.
	Characteristics []*string `json:"characteristics,omitempty" tf:"characteristics,omitempty"`

	// An expression that defines when the rate limit counter should be incremented. It defaults to the same as the rule's expression.
	CountingExpression *string `json:"countingExpression,omitempty" tf:"counting_expression,omitempty"`

	// Period of time in seconds after which the action will be disabled following its first execution.
	MitigationTimeout *float64 `json:"mitigationTimeout,omitempty" tf:"mitigation_timeout,omitempty"`

	// Period in seconds over which the counter is being incremented.
	Period *float64 `json:"period,omitempty" tf:"period,omitempty"`

	// The threshold of requests per period after which the action will be executed for the first time.
	RequestsPerPeriod *float64 `json:"requestsPerPeriod,omitempty" tf:"requests_per_period,omitempty"`

	// Whether counting is only performed when an origin is reached.
	RequestsToOrigin *bool `json:"requestsToOrigin,omitempty" tf:"requests_to_origin,omitempty"`

	// The score threshold per period for which the action will be executed the first time.
	ScorePerPeriod *float64 `json:"scorePerPeriod,omitempty" tf:"score_per_period,omitempty"`

	// A response header name provided by the origin, which contains the score to increment rate limit counter with.
	ScoreResponseHeaderName *string `json:"scoreResponseHeaderName,omitempty" tf:"score_response_header_name,omitempty"`
}

type RatelimitParameters struct {

	// Characteristics of the request on which the rate limit counter will be incremented.
	// +kubebuilder:validation:Optional
	Characteristics []*string `json:"characteristics" tf:"characteristics,omitempty"`

	// An expression that defines when the rate limit counter should be incremented. It defaults to the same as the rule's expression.
	// +kubebuilder:validation:Optional
	CountingExpression *string `json:"countingExpression,omitempty" tf:"counting_expression,omitempty"`

	// Period of time in seconds after which the action will be disabled following its first execution.
	// +kubebuilder:validation:Optional
	MitigationTimeout *float64 `json:"mitigationTimeout,omitempty" tf:"mitigation_timeout,omitempty"`

	// Period in seconds over which the counter is being incremented.
	// +kubebuilder:validation:Optional
	Period *float64 `json:"period" tf:"period,omitempty"`

	// The threshold of requests per period after which the action will be executed for the first time.
	// +kubebuilder:validation:Optional
	RequestsPerPeriod *float64 `json:"requestsPerPeriod,omitempty" tf:"requests_per_period,omitempty"`

	// Whether counting is only performed when an origin is reached.
	// +kubebuilder:validation:Optional
	RequestsToOrigin *bool `json:"requestsToOrigin,omitempty" tf:"requests_to_origin,omitempty"`

	// The score threshold per period for which the action will be executed the first time.
	// +kubebuilder:validation:Optional
	ScorePerPeriod *float64 `json:"scorePerPeriod,omitempty" tf:"score_per_period,omitempty"`

	// A response header name provided by the origin, which contains the score to increment rate limit counter with.
	// +kubebuilder:validation:Optional
	ScoreResponseHeaderName *string `json:"scoreResponseHeaderName,omitempty" tf:"score_response_header_name,omitempty"`
}

type RawResponseFieldsInitParameters struct {

	// The name of the response header.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Whether to log duplicate values of the same header.
	PreserveDuplicates *bool `json:"preserveDuplicates,omitempty" tf:"preserve_duplicates,omitempty"`
}

type RawResponseFieldsObservation struct {

	// The name of the response header.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Whether to log duplicate values of the same header.
	PreserveDuplicates *bool `json:"preserveDuplicates,omitempty" tf:"preserve_duplicates,omitempty"`
}

type RawResponseFieldsParameters struct {

	// The name of the response header.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// Whether to log duplicate values of the same header.
	// +kubebuilder:validation:Optional
	PreserveDuplicates *bool `json:"preserveDuplicates,omitempty" tf:"preserve_duplicates,omitempty"`
}

type RequestFieldsInitParameters struct {

	// The name of the header.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type RequestFieldsObservation struct {

	// The name of the header.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type RequestFieldsParameters struct {

	// The name of the header.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`
}

type ResponseFieldsInitParameters struct {

	// The name of the response header.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Whether to log duplicate values of the same header.
	PreserveDuplicates *bool `json:"preserveDuplicates,omitempty" tf:"preserve_duplicates,omitempty"`
}

type ResponseFieldsObservation struct {

	// The name of the response header.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Whether to log duplicate values of the same header.
	PreserveDuplicates *bool `json:"preserveDuplicates,omitempty" tf:"preserve_duplicates,omitempty"`
}

type ResponseFieldsParameters struct {

	// The name of the response header.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// Whether to log duplicate values of the same header.
	// +kubebuilder:validation:Optional
	PreserveDuplicates *bool `json:"preserveDuplicates,omitempty" tf:"preserve_duplicates,omitempty"`
}

type ResponseInitParameters struct {

	// The content to return.
	Content *string `json:"content,omitempty" tf:"content,omitempty"`

	// The type of the content to return.
	ContentType *string `json:"contentType,omitempty" tf:"content_type,omitempty"`

	// The status code to return.
	StatusCode *float64 `json:"statusCode,omitempty" tf:"status_code,omitempty"`
}

type ResponseObservation struct {

	// The content to return.
	Content *string `json:"content,omitempty" tf:"content,omitempty"`

	// The type of the content to return.
	ContentType *string `json:"contentType,omitempty" tf:"content_type,omitempty"`

	// The status code to return.
	StatusCode *float64 `json:"statusCode,omitempty" tf:"status_code,omitempty"`
}

type ResponseParameters struct {

	// The content to return.
	// +kubebuilder:validation:Optional
	Content *string `json:"content" tf:"content,omitempty"`

	// The type of the content to return.
	// +kubebuilder:validation:Optional
	ContentType *string `json:"contentType" tf:"content_type,omitempty"`

	// The status code to return.
	// +kubebuilder:validation:Optional
	StatusCode *float64 `json:"statusCode" tf:"status_code,omitempty"`
}

type RulesInitParameters struct {

	// The action to perform when the rule matches.
	// Available values: "block", "challenge", "compress_response", "ddos_dynamic", "execute", "force_connection_close", "js_challenge", "log", "log_custom_field", "managed_challenge", "redirect", "rewrite", "route", "score", "serve_error", "set_cache_settings", "set_config", "skip".
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	ActionParameters *ActionParametersInitParameters `json:"actionParameters,omitempty" tf:"action_parameters,omitempty"`

	// An informative description of the rule.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Whether the rule should be executed.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	ExposedCredentialCheck *ExposedCredentialCheckInitParameters `json:"exposedCredentialCheck,omitempty" tf:"exposed_credential_check,omitempty"`

	// The expression defining which traffic will match the rule.
	Expression *string `json:"expression,omitempty" tf:"expression,omitempty"`

	Logging *LoggingInitParameters `json:"logging,omitempty" tf:"logging,omitempty"`

	Ratelimit *RatelimitInitParameters `json:"ratelimit,omitempty" tf:"ratelimit,omitempty"`

	// The reference of the rule (the rule's ID by default).
	Ref *string `json:"ref,omitempty" tf:"ref,omitempty"`
}

type RulesObservation struct {

	// The action to perform when the rule matches.
	// Available values: "block", "challenge", "compress_response", "ddos_dynamic", "execute", "force_connection_close", "js_challenge", "log", "log_custom_field", "managed_challenge", "redirect", "rewrite", "route", "score", "serve_error", "set_cache_settings", "set_config", "skip".
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	ActionParameters *ActionParametersObservation `json:"actionParameters,omitempty" tf:"action_parameters,omitempty"`

	// An informative description of the rule.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Whether the rule should be executed.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	ExposedCredentialCheck *ExposedCredentialCheckObservation `json:"exposedCredentialCheck,omitempty" tf:"exposed_credential_check,omitempty"`

	// The expression defining which traffic will match the rule.
	Expression *string `json:"expression,omitempty" tf:"expression,omitempty"`

	// The unique ID of the rule.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Logging *LoggingObservation `json:"logging,omitempty" tf:"logging,omitempty"`

	Ratelimit *RatelimitObservation `json:"ratelimit,omitempty" tf:"ratelimit,omitempty"`

	// The reference of the rule (the rule's ID by default).
	Ref *string `json:"ref,omitempty" tf:"ref,omitempty"`
}

type RulesParameters struct {

	// The action to perform when the rule matches.
	// Available values: "block", "challenge", "compress_response", "ddos_dynamic", "execute", "force_connection_close", "js_challenge", "log", "log_custom_field", "managed_challenge", "redirect", "rewrite", "route", "score", "serve_error", "set_cache_settings", "set_config", "skip".
	// +kubebuilder:validation:Optional
	Action *string `json:"action" tf:"action,omitempty"`

	// +kubebuilder:validation:Optional
	ActionParameters *ActionParametersParameters `json:"actionParameters,omitempty" tf:"action_parameters,omitempty"`

	// An informative description of the rule.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Whether the rule should be executed.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Optional
	ExposedCredentialCheck *ExposedCredentialCheckParameters `json:"exposedCredentialCheck,omitempty" tf:"exposed_credential_check,omitempty"`

	// The expression defining which traffic will match the rule.
	// +kubebuilder:validation:Optional
	Expression *string `json:"expression" tf:"expression,omitempty"`

	// +kubebuilder:validation:Optional
	Logging *LoggingParameters `json:"logging,omitempty" tf:"logging,omitempty"`

	// +kubebuilder:validation:Optional
	Ratelimit *RatelimitParameters `json:"ratelimit,omitempty" tf:"ratelimit,omitempty"`

	// The reference of the rule (the rule's ID by default).
	// +kubebuilder:validation:Optional
	Ref *string `json:"ref,omitempty" tf:"ref,omitempty"`
}

type RulesetInitParameters struct {

	// The unique ID of the account.
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	// An informative description of the ruleset.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The kind of the ruleset.
	// Available values: "managed", "custom", "root", "zone".
	Kind *string `json:"kind,omitempty" tf:"kind,omitempty"`

	// The human-readable name of the ruleset.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The phase of the ruleset.
	// Available values: "ddos_l4", "ddos_l7", "http_config_settings", "http_custom_errors", "http_log_custom_fields", "http_ratelimit", "http_request_cache_settings", "http_request_dynamic_redirect", "http_request_firewall_custom", "http_request_firewall_managed", "http_request_late_transform", "http_request_origin", "http_request_redirect", "http_request_sanitize", "http_request_sbfm", "http_request_transform", "http_response_compression", "http_response_firewall_managed", "http_response_headers_transform", "magic_transit", "magic_transit_ids_managed", "magic_transit_managed", "magic_transit_ratelimit".
	Phase *string `json:"phase,omitempty" tf:"phase,omitempty"`

	Rules []RulesInitParameters `json:"rules,omitempty" tf:"rules,omitempty"`

	// The unique ID of the zone.
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type RulesetObservation struct {

	// The unique ID of the account.
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	// An informative description of the ruleset.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The kind of the ruleset.
	// Available values: "managed", "custom", "root", "zone".
	Kind *string `json:"kind,omitempty" tf:"kind,omitempty"`

	// The timestamp of when the ruleset was last modified.
	LastUpdated *string `json:"lastUpdated,omitempty" tf:"last_updated,omitempty"`

	// The human-readable name of the ruleset.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The phase of the ruleset.
	// Available values: "ddos_l4", "ddos_l7", "http_config_settings", "http_custom_errors", "http_log_custom_fields", "http_ratelimit", "http_request_cache_settings", "http_request_dynamic_redirect", "http_request_firewall_custom", "http_request_firewall_managed", "http_request_late_transform", "http_request_origin", "http_request_redirect", "http_request_sanitize", "http_request_sbfm", "http_request_transform", "http_response_compression", "http_response_firewall_managed", "http_response_headers_transform", "magic_transit", "magic_transit_ids_managed", "magic_transit_managed", "magic_transit_ratelimit".
	Phase *string `json:"phase,omitempty" tf:"phase,omitempty"`

	Rules []RulesObservation `json:"rules,omitempty" tf:"rules,omitempty"`

	// The version of the ruleset.
	Version *string `json:"version,omitempty" tf:"version,omitempty"`

	// The unique ID of the zone.
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type RulesetParameters struct {

	// The unique ID of the account.
	// +kubebuilder:validation:Optional
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	// An informative description of the ruleset.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The kind of the ruleset.
	// Available values: "managed", "custom", "root", "zone".
	// +kubebuilder:validation:Optional
	Kind *string `json:"kind,omitempty" tf:"kind,omitempty"`

	// The human-readable name of the ruleset.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The phase of the ruleset.
	// Available values: "ddos_l4", "ddos_l7", "http_config_settings", "http_custom_errors", "http_log_custom_fields", "http_ratelimit", "http_request_cache_settings", "http_request_dynamic_redirect", "http_request_firewall_custom", "http_request_firewall_managed", "http_request_late_transform", "http_request_origin", "http_request_redirect", "http_request_sanitize", "http_request_sbfm", "http_request_transform", "http_response_compression", "http_response_firewall_managed", "http_response_headers_transform", "magic_transit", "magic_transit_ids_managed", "magic_transit_managed", "magic_transit_ratelimit".
	// +kubebuilder:validation:Optional
	Phase *string `json:"phase,omitempty" tf:"phase,omitempty"`

	// +kubebuilder:validation:Optional
	Rules []RulesParameters `json:"rules,omitempty" tf:"rules,omitempty"`

	// The unique ID of the zone.
	// +kubebuilder:validation:Optional
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type ServeStaleInitParameters struct {

	// Whether Cloudflare should disable serving stale content while getting the latest content from the origin.
	DisableStaleWhileUpdating *bool `json:"disableStaleWhileUpdating,omitempty" tf:"disable_stale_while_updating,omitempty"`
}

type ServeStaleObservation struct {

	// Whether Cloudflare should disable serving stale content while getting the latest content from the origin.
	DisableStaleWhileUpdating *bool `json:"disableStaleWhileUpdating,omitempty" tf:"disable_stale_while_updating,omitempty"`
}

type ServeStaleParameters struct {

	// Whether Cloudflare should disable serving stale content while getting the latest content from the origin.
	// +kubebuilder:validation:Optional
	DisableStaleWhileUpdating *bool `json:"disableStaleWhileUpdating,omitempty" tf:"disable_stale_while_updating,omitempty"`
}

type SniInitParameters struct {

	// A value to override the SNI to.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type SniObservation struct {

	// A value to override the SNI to.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type SniParameters struct {

	// A value to override the SNI to.
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type StatusCodeRangeInitParameters struct {

	// The lower bound of the range.
	From *float64 `json:"from,omitempty" tf:"from,omitempty"`

	// The upper bound of the range.
	To *float64 `json:"to,omitempty" tf:"to,omitempty"`
}

type StatusCodeRangeObservation struct {

	// The lower bound of the range.
	From *float64 `json:"from,omitempty" tf:"from,omitempty"`

	// The upper bound of the range.
	To *float64 `json:"to,omitempty" tf:"to,omitempty"`
}

type StatusCodeRangeParameters struct {

	// The lower bound of the range.
	// +kubebuilder:validation:Optional
	From *float64 `json:"from,omitempty" tf:"from,omitempty"`

	// The upper bound of the range.
	// +kubebuilder:validation:Optional
	To *float64 `json:"to,omitempty" tf:"to,omitempty"`
}

type StatusCodeTTLInitParameters struct {

	// A single status code to apply the TTL to.
	StatusCode *float64 `json:"statusCode,omitempty" tf:"status_code,omitempty"`

	StatusCodeRange *StatusCodeRangeInitParameters `json:"statusCodeRange,omitempty" tf:"status_code_range,omitempty"`

	// The time to cache the response for (in seconds). A value of 0 is equivalent to setting the cache control header with the value "no-cache". A value of -1 is equivalent to setting the cache control header with the value of "no-store".
	Value *float64 `json:"value,omitempty" tf:"value,omitempty"`
}

type StatusCodeTTLObservation struct {

	// A single status code to apply the TTL to.
	StatusCode *float64 `json:"statusCode,omitempty" tf:"status_code,omitempty"`

	StatusCodeRange *StatusCodeRangeObservation `json:"statusCodeRange,omitempty" tf:"status_code_range,omitempty"`

	// The time to cache the response for (in seconds). A value of 0 is equivalent to setting the cache control header with the value "no-cache". A value of -1 is equivalent to setting the cache control header with the value of "no-store".
	Value *float64 `json:"value,omitempty" tf:"value,omitempty"`
}

type StatusCodeTTLParameters struct {

	// A single status code to apply the TTL to.
	// +kubebuilder:validation:Optional
	StatusCode *float64 `json:"statusCode,omitempty" tf:"status_code,omitempty"`

	// +kubebuilder:validation:Optional
	StatusCodeRange *StatusCodeRangeParameters `json:"statusCodeRange,omitempty" tf:"status_code_range,omitempty"`

	// The time to cache the response for (in seconds). A value of 0 is equivalent to setting the cache control header with the value "no-cache". A value of -1 is equivalent to setting the cache control header with the value of "no-store".
	// +kubebuilder:validation:Optional
	Value *float64 `json:"value" tf:"value,omitempty"`
}

type TargetURLInitParameters struct {

	// An expression that evaluates to a URL to redirect the request to.
	Expression *string `json:"expression,omitempty" tf:"expression,omitempty"`

	// A URL to redirect the request to.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type TargetURLObservation struct {

	// An expression that evaluates to a URL to redirect the request to.
	Expression *string `json:"expression,omitempty" tf:"expression,omitempty"`

	// A URL to redirect the request to.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type TargetURLParameters struct {

	// An expression that evaluates to a URL to redirect the request to.
	// +kubebuilder:validation:Optional
	Expression *string `json:"expression,omitempty" tf:"expression,omitempty"`

	// A URL to redirect the request to.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type TransformedRequestFieldsInitParameters struct {

	// The name of the header.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type TransformedRequestFieldsObservation struct {

	// The name of the header.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type TransformedRequestFieldsParameters struct {

	// The name of the header.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`
}

type URIInitParameters struct {
	Path *PathInitParameters `json:"path,omitempty" tf:"path,omitempty"`

	Query *QueryInitParameters `json:"query,omitempty" tf:"query,omitempty"`
}

type URIObservation struct {
	Path *PathObservation `json:"path,omitempty" tf:"path,omitempty"`

	Query *QueryObservation `json:"query,omitempty" tf:"query,omitempty"`
}

type URIParameters struct {

	// +kubebuilder:validation:Optional
	Path *PathParameters `json:"path,omitempty" tf:"path,omitempty"`

	// +kubebuilder:validation:Optional
	Query *QueryParameters `json:"query,omitempty" tf:"query,omitempty"`
}

type UserInitParameters struct {

	// Whether to use the user agent's device type in the cache key.
	DeviceType *bool `json:"deviceType,omitempty" tf:"device_type,omitempty"`

	// Whether to use the user agents's country in the cache key.
	Geo *bool `json:"geo,omitempty" tf:"geo,omitempty"`

	// Whether to use the user agent's language in the cache key.
	Lang *bool `json:"lang,omitempty" tf:"lang,omitempty"`
}

type UserObservation struct {

	// Whether to use the user agent's device type in the cache key.
	DeviceType *bool `json:"deviceType,omitempty" tf:"device_type,omitempty"`

	// Whether to use the user agents's country in the cache key.
	Geo *bool `json:"geo,omitempty" tf:"geo,omitempty"`

	// Whether to use the user agent's language in the cache key.
	Lang *bool `json:"lang,omitempty" tf:"lang,omitempty"`
}

type UserParameters struct {

	// Whether to use the user agent's device type in the cache key.
	// +kubebuilder:validation:Optional
	DeviceType *bool `json:"deviceType,omitempty" tf:"device_type,omitempty"`

	// Whether to use the user agents's country in the cache key.
	// +kubebuilder:validation:Optional
	Geo *bool `json:"geo,omitempty" tf:"geo,omitempty"`

	// Whether to use the user agent's language in the cache key.
	// +kubebuilder:validation:Optional
	Lang *bool `json:"lang,omitempty" tf:"lang,omitempty"`
}

// RulesetSpec defines the desired state of Ruleset
type RulesetSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     RulesetParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider RulesetInitParameters `json:"initProvider,omitempty"`
}

// RulesetStatus defines the observed state of Ruleset.
type RulesetStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        RulesetObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Ruleset is the Schema for the Rulesets API. <no value>
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,cloudflare}
type Ruleset struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.kind) || (has(self.initProvider) && has(self.initProvider.kind))",message="spec.forProvider.kind is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.phase) || (has(self.initProvider) && has(self.initProvider.phase))",message="spec.forProvider.phase is a required parameter"
	Spec   RulesetSpec   `json:"spec"`
	Status RulesetStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// RulesetList contains a list of Rulesets
type RulesetList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Ruleset `json:"items"`
}

// Repository type metadata.
var (
	Ruleset_Kind             = "Ruleset"
	Ruleset_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Ruleset_Kind}.String()
	Ruleset_KindAPIVersion   = Ruleset_Kind + "." + CRDGroupVersion.String()
	Ruleset_GroupVersionKind = CRDGroupVersion.WithKind(Ruleset_Kind)
)

func init() {
	SchemeBuilder.Register(&Ruleset{}, &RulesetList{})
}
