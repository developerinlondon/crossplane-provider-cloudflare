// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
)

type CustomCertBundleInitParameters struct {

	// If a custom uploaded certificate is used.
	CustomCertificate *string `json:"customCertificate,omitempty" tf:"custom_certificate,omitempty"`

	// The key for a custom uploaded certificate.
	CustomKeySecretRef v1.SecretKeySelector `json:"customKeySecretRef" tf:"-"`
}

type CustomCertBundleObservation struct {

	// If a custom uploaded certificate is used.
	CustomCertificate *string `json:"customCertificate,omitempty" tf:"custom_certificate,omitempty"`
}

type CustomCertBundleParameters struct {

	// If a custom uploaded certificate is used.
	// +kubebuilder:validation:Optional
	CustomCertificate *string `json:"customCertificate" tf:"custom_certificate,omitempty"`

	// The key for a custom uploaded certificate.
	// +kubebuilder:validation:Optional
	CustomKeySecretRef v1.SecretKeySelector `json:"customKeySecretRef" tf:"-"`
}

type HostnameInitParameters struct {

	// Unique key/value metadata for this hostname. These are per-hostname (customer) settings.
	// +mapType=granular
	CustomMetadata map[string]*string `json:"customMetadata,omitempty" tf:"custom_metadata,omitempty"`

	// a valid hostname that’s been added to your DNS zone as an A, AAAA, or CNAME record.
	CustomOriginServer *string `json:"customOriginServer,omitempty" tf:"custom_origin_server,omitempty"`

	// A hostname that will be sent to your custom origin server as SNI for TLS handshake. This can be a valid subdomain of the zone or custom origin server name or the string ':request_host_header:' which will cause the host header in the request to be used as SNI. Not configurable with default/fallback origin server.
	CustomOriginSni *string `json:"customOriginSni,omitempty" tf:"custom_origin_sni,omitempty"`

	// The custom hostname that will point to your hostname via CNAME.
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	SSL *SSLInitParameters `json:"ssl,omitempty" tf:"ssl,omitempty"`

	// Identifier.
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type HostnameObservation struct {

	// This is the time the hostname was created.
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	// Unique key/value metadata for this hostname. These are per-hostname (customer) settings.
	// +mapType=granular
	CustomMetadata map[string]*string `json:"customMetadata,omitempty" tf:"custom_metadata,omitempty"`

	// a valid hostname that’s been added to your DNS zone as an A, AAAA, or CNAME record.
	CustomOriginServer *string `json:"customOriginServer,omitempty" tf:"custom_origin_server,omitempty"`

	// A hostname that will be sent to your custom origin server as SNI for TLS handshake. This can be a valid subdomain of the zone or custom origin server name or the string ':request_host_header:' which will cause the host header in the request to be used as SNI. Not configurable with default/fallback origin server.
	CustomOriginSni *string `json:"customOriginSni,omitempty" tf:"custom_origin_sni,omitempty"`

	// The custom hostname that will point to your hostname via CNAME.
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	OwnershipVerification *OwnershipVerificationObservation `json:"ownershipVerification,omitempty" tf:"ownership_verification,omitempty"`

	OwnershipVerificationHTTP *OwnershipVerificationHTTPObservation `json:"ownershipVerificationHttp,omitempty" tf:"ownership_verification_http,omitempty"`

	SSL *SSLObservation `json:"ssl,omitempty" tf:"ssl,omitempty"`

	// Status of the hostname's activation.
	// Available values: "active", "pending", "active_redeploying", "moved", "pending_deletion", "deleted", "pending_blocked", "pending_migration", "pending_provisioned", "test_pending", "test_active", "test_active_apex", "test_blocked", "test_failed", "provisioned", "blocked".
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	// These are errors that were encountered while trying to activate a hostname.
	VerificationErrors []*string `json:"verificationErrors,omitempty" tf:"verification_errors,omitempty"`

	// Identifier.
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type HostnameParameters struct {

	// Unique key/value metadata for this hostname. These are per-hostname (customer) settings.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	CustomMetadata map[string]*string `json:"customMetadata,omitempty" tf:"custom_metadata,omitempty"`

	// a valid hostname that’s been added to your DNS zone as an A, AAAA, or CNAME record.
	// +kubebuilder:validation:Optional
	CustomOriginServer *string `json:"customOriginServer,omitempty" tf:"custom_origin_server,omitempty"`

	// A hostname that will be sent to your custom origin server as SNI for TLS handshake. This can be a valid subdomain of the zone or custom origin server name or the string ':request_host_header:' which will cause the host header in the request to be used as SNI. Not configurable with default/fallback origin server.
	// +kubebuilder:validation:Optional
	CustomOriginSni *string `json:"customOriginSni,omitempty" tf:"custom_origin_sni,omitempty"`

	// The custom hostname that will point to your hostname via CNAME.
	// +kubebuilder:validation:Optional
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	// +kubebuilder:validation:Optional
	SSL *SSLParameters `json:"ssl,omitempty" tf:"ssl,omitempty"`

	// Identifier.
	// +kubebuilder:validation:Optional
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type OwnershipVerificationHTTPInitParameters struct {
}

type OwnershipVerificationHTTPObservation struct {

	// Token to be served.
	HTTPBody *string `json:"httpBody,omitempty" tf:"http_body,omitempty"`

	// The HTTP URL that will be checked during custom hostname verification and where the customer should host the token.
	HTTPURL *string `json:"httpUrl,omitempty" tf:"http_url,omitempty"`
}

type OwnershipVerificationHTTPParameters struct {
}

type OwnershipVerificationInitParameters struct {
}

type OwnershipVerificationObservation struct {

	// DNS Name for record.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// DNS Record type.
	// Available values: "txt".
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Content for the record.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type OwnershipVerificationParameters struct {
}

type SSLInitParameters struct {

	// A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
	// Available values: "ubiquitous", "optimal", "force".
	BundleMethod *string `json:"bundleMethod,omitempty" tf:"bundle_method,omitempty"`

	// The Certificate Authority that will issue the certificate
	// Available values: "digicert", "google", "lets_encrypt", "ssl_com".
	CertificateAuthority *string `json:"certificateAuthority,omitempty" tf:"certificate_authority,omitempty"`

	// Whether or not to add Cloudflare Branding for the order.  This will add a subdomain of sni.cloudflaressl.com as the Common Name if set to true
	CloudflareBranding *bool `json:"cloudflareBranding,omitempty" tf:"cloudflare_branding,omitempty"`

	CustomCertBundle []CustomCertBundleInitParameters `json:"customCertBundle,omitempty" tf:"custom_cert_bundle,omitempty"`

	// If a custom uploaded certificate is used.
	CustomCertificate *string `json:"customCertificate,omitempty" tf:"custom_certificate,omitempty"`

	// The key for a custom uploaded certificate.
	CustomKeySecretRef *v1.SecretKeySelector `json:"customKeySecretRef,omitempty" tf:"-"`

	// Domain control validation (DCV) method used for this hostname.
	// Available values: "http", "txt", "email".
	Method *string `json:"method,omitempty" tf:"method,omitempty"`

	Settings *SettingsInitParameters `json:"settings,omitempty" tf:"settings,omitempty"`

	// Level of validation to be used for this hostname. Domain validation (dv) must be used.
	// Available values: "dv".
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Indicates whether the certificate covers a wildcard.
	Wildcard *bool `json:"wildcard,omitempty" tf:"wildcard,omitempty"`
}

type SSLObservation struct {

	// A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
	// Available values: "ubiquitous", "optimal", "force".
	BundleMethod *string `json:"bundleMethod,omitempty" tf:"bundle_method,omitempty"`

	// The Certificate Authority that will issue the certificate
	// Available values: "digicert", "google", "lets_encrypt", "ssl_com".
	CertificateAuthority *string `json:"certificateAuthority,omitempty" tf:"certificate_authority,omitempty"`

	// Whether or not to add Cloudflare Branding for the order.  This will add a subdomain of sni.cloudflaressl.com as the Common Name if set to true
	CloudflareBranding *bool `json:"cloudflareBranding,omitempty" tf:"cloudflare_branding,omitempty"`

	CustomCertBundle []CustomCertBundleObservation `json:"customCertBundle,omitempty" tf:"custom_cert_bundle,omitempty"`

	// If a custom uploaded certificate is used.
	CustomCertificate *string `json:"customCertificate,omitempty" tf:"custom_certificate,omitempty"`

	// Domain control validation (DCV) method used for this hostname.
	// Available values: "http", "txt", "email".
	Method *string `json:"method,omitempty" tf:"method,omitempty"`

	Settings *SettingsObservation `json:"settings,omitempty" tf:"settings,omitempty"`

	// Level of validation to be used for this hostname. Domain validation (dv) must be used.
	// Available values: "dv".
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Indicates whether the certificate covers a wildcard.
	Wildcard *bool `json:"wildcard,omitempty" tf:"wildcard,omitempty"`
}

type SSLParameters struct {

	// A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
	// Available values: "ubiquitous", "optimal", "force".
	// +kubebuilder:validation:Optional
	BundleMethod *string `json:"bundleMethod,omitempty" tf:"bundle_method,omitempty"`

	// The Certificate Authority that will issue the certificate
	// Available values: "digicert", "google", "lets_encrypt", "ssl_com".
	// +kubebuilder:validation:Optional
	CertificateAuthority *string `json:"certificateAuthority,omitempty" tf:"certificate_authority,omitempty"`

	// Whether or not to add Cloudflare Branding for the order.  This will add a subdomain of sni.cloudflaressl.com as the Common Name if set to true
	// +kubebuilder:validation:Optional
	CloudflareBranding *bool `json:"cloudflareBranding,omitempty" tf:"cloudflare_branding,omitempty"`

	// +kubebuilder:validation:Optional
	CustomCertBundle []CustomCertBundleParameters `json:"customCertBundle,omitempty" tf:"custom_cert_bundle,omitempty"`

	// If a custom uploaded certificate is used.
	// +kubebuilder:validation:Optional
	CustomCertificate *string `json:"customCertificate,omitempty" tf:"custom_certificate,omitempty"`

	// The key for a custom uploaded certificate.
	// +kubebuilder:validation:Optional
	CustomKeySecretRef *v1.SecretKeySelector `json:"customKeySecretRef,omitempty" tf:"-"`

	// Domain control validation (DCV) method used for this hostname.
	// Available values: "http", "txt", "email".
	// +kubebuilder:validation:Optional
	Method *string `json:"method,omitempty" tf:"method,omitempty"`

	// +kubebuilder:validation:Optional
	Settings *SettingsParameters `json:"settings,omitempty" tf:"settings,omitempty"`

	// Level of validation to be used for this hostname. Domain validation (dv) must be used.
	// Available values: "dv".
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Indicates whether the certificate covers a wildcard.
	// +kubebuilder:validation:Optional
	Wildcard *bool `json:"wildcard,omitempty" tf:"wildcard,omitempty"`
}

type SettingsInitParameters struct {

	// An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
	Ciphers []*string `json:"ciphers,omitempty" tf:"ciphers,omitempty"`

	// Whether or not Early Hints is enabled.
	// Available values: "on", "off".
	EarlyHints *string `json:"earlyHints,omitempty" tf:"early_hints,omitempty"`

	// Whether or not HTTP2 is enabled.
	// Available values: "on", "off".
	Http2 *string `json:"http2,omitempty" tf:"http2,omitempty"`

	// The minimum TLS version supported.
	// Available values: "1.0", "1.1", "1.2", "1.3".
	MinTLSVersion *string `json:"minTlsVersion,omitempty" tf:"min_tls_version,omitempty"`

	// Whether or not TLS 1.3 is enabled.
	// Available values: "on", "off".
	TLS13 *string `json:"tls13,omitempty" tf:"tls_1_3,omitempty"`
}

type SettingsObservation struct {

	// An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
	Ciphers []*string `json:"ciphers,omitempty" tf:"ciphers,omitempty"`

	// Whether or not Early Hints is enabled.
	// Available values: "on", "off".
	EarlyHints *string `json:"earlyHints,omitempty" tf:"early_hints,omitempty"`

	// Whether or not HTTP2 is enabled.
	// Available values: "on", "off".
	Http2 *string `json:"http2,omitempty" tf:"http2,omitempty"`

	// The minimum TLS version supported.
	// Available values: "1.0", "1.1", "1.2", "1.3".
	MinTLSVersion *string `json:"minTlsVersion,omitempty" tf:"min_tls_version,omitempty"`

	// Whether or not TLS 1.3 is enabled.
	// Available values: "on", "off".
	TLS13 *string `json:"tls13,omitempty" tf:"tls_1_3,omitempty"`
}

type SettingsParameters struct {

	// An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
	// +kubebuilder:validation:Optional
	Ciphers []*string `json:"ciphers,omitempty" tf:"ciphers,omitempty"`

	// Whether or not Early Hints is enabled.
	// Available values: "on", "off".
	// +kubebuilder:validation:Optional
	EarlyHints *string `json:"earlyHints,omitempty" tf:"early_hints,omitempty"`

	// Whether or not HTTP2 is enabled.
	// Available values: "on", "off".
	// +kubebuilder:validation:Optional
	Http2 *string `json:"http2,omitempty" tf:"http2,omitempty"`

	// The minimum TLS version supported.
	// Available values: "1.0", "1.1", "1.2", "1.3".
	// +kubebuilder:validation:Optional
	MinTLSVersion *string `json:"minTlsVersion,omitempty" tf:"min_tls_version,omitempty"`

	// Whether or not TLS 1.3 is enabled.
	// Available values: "on", "off".
	// +kubebuilder:validation:Optional
	TLS13 *string `json:"tls13,omitempty" tf:"tls_1_3,omitempty"`
}

// HostnameSpec defines the desired state of Hostname
type HostnameSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     HostnameParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider HostnameInitParameters `json:"initProvider,omitempty"`
}

// HostnameStatus defines the observed state of Hostname.
type HostnameStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        HostnameObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Hostname is the Schema for the Hostnames API. <no value>
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,cloudflare}
type Hostname struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.hostname) || (has(self.initProvider) && has(self.initProvider.hostname))",message="spec.forProvider.hostname is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.ssl) || (has(self.initProvider) && has(self.initProvider.ssl))",message="spec.forProvider.ssl is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.zoneId) || (has(self.initProvider) && has(self.initProvider.zoneId))",message="spec.forProvider.zoneId is a required parameter"
	Spec   HostnameSpec   `json:"spec"`
	Status HostnameStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// HostnameList contains a list of Hostnames
type HostnameList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Hostname `json:"items"`
}

// Repository type metadata.
var (
	Hostname_Kind             = "Hostname"
	Hostname_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Hostname_Kind}.String()
	Hostname_KindAPIVersion   = Hostname_Kind + "." + CRDGroupVersion.String()
	Hostname_GroupVersionKind = CRDGroupVersion.WithKind(Hostname_Kind)
)

func init() {
	SchemeBuilder.Register(&Hostname{}, &HostnameList{})
}
