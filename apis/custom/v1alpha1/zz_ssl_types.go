// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
)

type GeoRestrictionsInitParameters struct {

	// Available values: "us", "eu", "highest_security".
	Label *string `json:"label,omitempty" tf:"label,omitempty"`
}

type GeoRestrictionsObservation struct {

	// Available values: "us", "eu", "highest_security".
	Label *string `json:"label,omitempty" tf:"label,omitempty"`
}

type GeoRestrictionsParameters struct {

	// Available values: "us", "eu", "highest_security".
	// +kubebuilder:validation:Optional
	Label *string `json:"label,omitempty" tf:"label,omitempty"`
}

type KeylessServerInitParameters struct {
}

type KeylessServerObservation struct {

	// When the Keyless SSL was created.
	CreatedOn *string `json:"createdOn,omitempty" tf:"created_on,omitempty"`

	// Whether or not the Keyless SSL is on or off.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The keyless SSL name.
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// Keyless certificate identifier tag.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// When the Keyless SSL was last modified.
	ModifiedOn *string `json:"modifiedOn,omitempty" tf:"modified_on,omitempty"`

	// The keyless SSL name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Available permissions for the Keyless SSL for the current user requesting the item.
	Permissions []*string `json:"permissions,omitempty" tf:"permissions,omitempty"`

	// The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// Status of the Keyless SSL.
	// Available values: "active", "deleted".
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	Tunnel *TunnelObservation `json:"tunnel,omitempty" tf:"tunnel,omitempty"`
}

type KeylessServerParameters struct {
}

type SSLInitParameters_2 struct {

	// A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
	// Available values: "ubiquitous", "optimal", "force".
	BundleMethod *string `json:"bundleMethod,omitempty" tf:"bundle_method,omitempty"`

	// The zone's SSL certificate or certificate and the intermediate(s).
	Certificate *string `json:"certificate,omitempty" tf:"certificate,omitempty"`

	GeoRestrictions *GeoRestrictionsInitParameters `json:"geoRestrictions,omitempty" tf:"geo_restrictions,omitempty"`

	// Specify the policy that determines the region where your private key will be held locally. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Any combination of countries, specified by their two letter country code (https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements) can be chosen, such as 'country: IN', as well as 'region: EU' which refers to the EU region. If there are too few data centers satisfying the policy, it will be rejected.
	Policy *string `json:"policy,omitempty" tf:"policy,omitempty"`

	// The zone's private key.
	PrivateKeySecretRef v1.SecretKeySelector `json:"privateKeySecretRef" tf:"-"`

	// The type 'legacy_custom' enables support for legacy clients which do not include SNI in the TLS handshake.
	// Available values: "legacy_custom", "sni_custom".
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Identifier.
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type SSLObservation_2 struct {

	// A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
	// Available values: "ubiquitous", "optimal", "force".
	BundleMethod *string `json:"bundleMethod,omitempty" tf:"bundle_method,omitempty"`

	// The zone's SSL certificate or certificate and the intermediate(s).
	Certificate *string `json:"certificate,omitempty" tf:"certificate,omitempty"`

	// When the certificate from the authority expires.
	ExpiresOn *string `json:"expiresOn,omitempty" tf:"expires_on,omitempty"`

	GeoRestrictions *GeoRestrictionsObservation `json:"geoRestrictions,omitempty" tf:"geo_restrictions,omitempty"`

	Hosts []*string `json:"hosts,omitempty" tf:"hosts,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The certificate authority that issued the certificate.
	Issuer *string `json:"issuer,omitempty" tf:"issuer,omitempty"`

	KeylessServer *KeylessServerObservation `json:"keylessServer,omitempty" tf:"keyless_server,omitempty"`

	// When the certificate was last modified.
	ModifiedOn *string `json:"modifiedOn,omitempty" tf:"modified_on,omitempty"`

	// Specify the policy that determines the region where your private key will be held locally. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Any combination of countries, specified by their two letter country code (https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements) can be chosen, such as 'country: IN', as well as 'region: EU' which refers to the EU region. If there are too few data centers satisfying the policy, it will be rejected.
	Policy *string `json:"policy,omitempty" tf:"policy,omitempty"`

	// The order/priority in which the certificate will be used in a request. The higher priority will break ties across overlapping 'legacy_custom' certificates, but 'legacy_custom' certificates will always supercede 'sni_custom' certificates.
	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`

	// The type of hash used for the certificate.
	Signature *string `json:"signature,omitempty" tf:"signature,omitempty"`

	// Status of the zone's custom SSL.
	// Available values: "active", "expired", "deleted", "pending", "initializing".
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	// The type 'legacy_custom' enables support for legacy clients which do not include SNI in the TLS handshake.
	// Available values: "legacy_custom", "sni_custom".
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// When the certificate was uploaded to Cloudflare.
	UploadedOn *string `json:"uploadedOn,omitempty" tf:"uploaded_on,omitempty"`

	// Identifier.
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type SSLParameters_2 struct {

	// A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
	// Available values: "ubiquitous", "optimal", "force".
	// +kubebuilder:validation:Optional
	BundleMethod *string `json:"bundleMethod,omitempty" tf:"bundle_method,omitempty"`

	// The zone's SSL certificate or certificate and the intermediate(s).
	// +kubebuilder:validation:Optional
	Certificate *string `json:"certificate,omitempty" tf:"certificate,omitempty"`

	// +kubebuilder:validation:Optional
	GeoRestrictions *GeoRestrictionsParameters `json:"geoRestrictions,omitempty" tf:"geo_restrictions,omitempty"`

	// Specify the policy that determines the region where your private key will be held locally. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Any combination of countries, specified by their two letter country code (https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements) can be chosen, such as 'country: IN', as well as 'region: EU' which refers to the EU region. If there are too few data centers satisfying the policy, it will be rejected.
	// +kubebuilder:validation:Optional
	Policy *string `json:"policy,omitempty" tf:"policy,omitempty"`

	// The zone's private key.
	// +kubebuilder:validation:Optional
	PrivateKeySecretRef v1.SecretKeySelector `json:"privateKeySecretRef" tf:"-"`

	// The type 'legacy_custom' enables support for legacy clients which do not include SNI in the TLS handshake.
	// Available values: "legacy_custom", "sni_custom".
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Identifier.
	// +kubebuilder:validation:Optional
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type TunnelInitParameters struct {
}

type TunnelObservation struct {

	// Private IP of the Key Server Host
	PrivateIP *string `json:"privateIp,omitempty" tf:"private_ip,omitempty"`

	// Cloudflare Tunnel Virtual Network ID
	VnetID *string `json:"vnetId,omitempty" tf:"vnet_id,omitempty"`
}

type TunnelParameters struct {
}

// SSLSpec defines the desired state of SSL
type SSLSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     SSLParameters_2 `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider SSLInitParameters_2 `json:"initProvider,omitempty"`
}

// SSLStatus defines the observed state of SSL.
type SSLStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        SSLObservation_2 `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// SSL is the Schema for the SSLs API. <no value>
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,cloudflare}
type SSL struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.certificate) || (has(self.initProvider) && has(self.initProvider.certificate))",message="spec.forProvider.certificate is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.privateKeySecretRef)",message="spec.forProvider.privateKeySecretRef is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.zoneId) || (has(self.initProvider) && has(self.initProvider.zoneId))",message="spec.forProvider.zoneId is a required parameter"
	Spec   SSLSpec   `json:"spec"`
	Status SSLStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// SSLList contains a list of SSLs
type SSLList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []SSL `json:"items"`
}

// Repository type metadata.
var (
	SSL_Kind             = "SSL"
	SSL_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: SSL_Kind}.String()
	SSL_KindAPIVersion   = SSL_Kind + "." + CRDGroupVersion.String()
	SSL_GroupVersionKind = CRDGroupVersion.WithKind(SSL_Kind)
)

func init() {
	SchemeBuilder.Register(&SSL{}, &SSLList{})
}
