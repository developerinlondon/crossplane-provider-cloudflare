// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
	v1apiextensions "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
)

type AssetsInitParameters struct {
	Config *ConfigInitParameters `json:"config,omitempty" tf:"config,omitempty"`

	// Path to the directory containing asset files to upload.
	Directory *string `json:"directory,omitempty" tf:"directory,omitempty"`

	// Token provided upon successful upload of all files from a registered manifest.
	JwtSecretRef *v1.SecretKeySelector `json:"jwtSecretRef,omitempty" tf:"-"`
}

type AssetsObservation struct {

	// The SHA-256 hash of the asset manifest of files to upload.
	AssetManifestSha256 *string `json:"assetManifestSha256,omitempty" tf:"asset_manifest_sha256,omitempty"`

	Config *ConfigObservation `json:"config,omitempty" tf:"config,omitempty"`

	// Path to the directory containing asset files to upload.
	Directory *string `json:"directory,omitempty" tf:"directory,omitempty"`
}

type AssetsParameters struct {

	// +kubebuilder:validation:Optional
	Config *ConfigParameters `json:"config,omitempty" tf:"config,omitempty"`

	// Path to the directory containing asset files to upload.
	// +kubebuilder:validation:Optional
	Directory *string `json:"directory,omitempty" tf:"directory,omitempty"`

	// Token provided upon successful upload of all files from a registered manifest.
	// +kubebuilder:validation:Optional
	JwtSecretRef *v1.SecretKeySelector `json:"jwtSecretRef,omitempty" tf:"-"`
}

type BindingsInitParameters struct {

	// Algorithm-specific key parameters. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#algorithm).
	Algorithm *string `json:"algorithm,omitempty" tf:"algorithm,omitempty"`

	// List of allowed destination addresses.
	AllowedDestinationAddresses []*string `json:"allowedDestinationAddresses,omitempty" tf:"allowed_destination_addresses,omitempty"`

	// List of allowed sender addresses.
	AllowedSenderAddresses []*string `json:"allowedSenderAddresses,omitempty" tf:"allowed_sender_addresses,omitempty"`

	// R2 bucket to bind to.
	BucketName *string `json:"bucketName,omitempty" tf:"bucket_name,omitempty"`

	// Identifier of the certificate to bind to.
	CertificateID *string `json:"certificateId,omitempty" tf:"certificate_id,omitempty"`

	// The exported class name of the Durable Object.
	ClassName *string `json:"className,omitempty" tf:"class_name,omitempty"`

	// The name of the dataset to bind to.
	Dataset *string `json:"dataset,omitempty" tf:"dataset,omitempty"`

	// Destination address for the email.
	DestinationAddress *string `json:"destinationAddress,omitempty" tf:"destination_address,omitempty"`

	// The environment of the script_name to bind to.
	Environment *string `json:"environment,omitempty" tf:"environment,omitempty"`

	// Data format of the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#format).
	// Available values: "raw", "pkcs8", "spki", "jwk".
	Format *string `json:"format,omitempty" tf:"format,omitempty"`

	// Identifier of the D1 database to bind to.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Name of the Vectorize index to bind to.
	IndexName *string `json:"indexName,omitempty" tf:"index_name,omitempty"`

	// JSON data to use.
	JSON *string `json:"json,omitempty" tf:"json,omitempty"`

	// The [jurisdiction](https://developers.cloudflare.com/r2/reference/data-location/#jurisdictional-restrictions) of the R2 bucket.
	// Available values: "eu", "fedramp".
	Jurisdiction *string `json:"jurisdiction,omitempty" tf:"jurisdiction,omitempty"`

	// Base64-encoded key data. Required if `format` is "raw", "pkcs8", or "spki".
	KeyBase64SecretRef *v1.SecretKeySelector `json:"keyBase64SecretRef,omitempty" tf:"-"`

	// Key data in [JSON Web Key](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#json_web_key) format. Required if `format` is "jwk".
	KeyJwkSecretRef *v1.SecretKeySelector `json:"keyJwkSecretRef,omitempty" tf:"-"`

	// A JavaScript variable name for the binding.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The name of the dispatch namespace.
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// Namespace identifier tag.
	NamespaceID *string `json:"namespaceId,omitempty" tf:"namespace_id,omitempty"`

	// The old name of the inherited binding. If set, the binding will be renamed from `old_name` to `name` in the new version. If not set, the binding will keep the same name between versions.
	OldName *string `json:"oldName,omitempty" tf:"old_name,omitempty"`

	Outbound *OutboundInitParameters `json:"outbound,omitempty" tf:"outbound,omitempty"`

	// The name of the file containing the data content. Only accepted for `service worker syntax` Workers.
	Part *string `json:"part,omitempty" tf:"part,omitempty"`

	// Name of the Pipeline to bind to.
	Pipeline *string `json:"pipeline,omitempty" tf:"pipeline,omitempty"`

	// Name of the Queue to bind to.
	QueueName *string `json:"queueName,omitempty" tf:"queue_name,omitempty"`

	// The script where the Durable Object is defined, if it is external to this Worker.
	ScriptName *string `json:"scriptName,omitempty" tf:"script_name,omitempty"`

	// Name of the secret in the store.
	SecretName *string `json:"secretName,omitempty" tf:"secret_name,omitempty"`

	// Name of Worker to bind to.
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// ID of the store containing the secret.
	StoreID *string `json:"storeId,omitempty" tf:"store_id,omitempty"`

	// The text value to use.
	TextSecretRef *v1.SecretKeySelector `json:"textSecretRef,omitempty" tf:"-"`

	// The kind of resource that the binding provides.
	// Available values: "ai", "analytics_engine", "assets", "browser", "d1", "data_blob", "dispatch_namespace", "durable_object_namespace", "hyperdrive", "inherit", "images", "json", "kv_namespace", "mtls_certificate", "plain_text", "pipelines", "queue", "r2_bucket", "secret_text", "send_email", "service", "tail_consumer", "text_blob", "vectorize", "version_metadata", "secrets_store_secret", "secret_key", "workflow", "wasm_module".
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Allowed operations with the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#keyUsages).
	// +listType=set
	Usages []*string `json:"usages,omitempty" tf:"usages,omitempty"`

	// Identifier for the version to inherit the binding from, which can be the version ID or the literal "latest" to inherit from the latest version. Defaults to inheriting the binding from the latest version.
	VersionID *string `json:"versionId,omitempty" tf:"version_id,omitempty"`

	// Name of the Workflow to bind to.
	WorkflowName *string `json:"workflowName,omitempty" tf:"workflow_name,omitempty"`
}

type BindingsObservation struct {

	// Algorithm-specific key parameters. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#algorithm).
	Algorithm *string `json:"algorithm,omitempty" tf:"algorithm,omitempty"`

	// List of allowed destination addresses.
	AllowedDestinationAddresses []*string `json:"allowedDestinationAddresses,omitempty" tf:"allowed_destination_addresses,omitempty"`

	// List of allowed sender addresses.
	AllowedSenderAddresses []*string `json:"allowedSenderAddresses,omitempty" tf:"allowed_sender_addresses,omitempty"`

	// R2 bucket to bind to.
	BucketName *string `json:"bucketName,omitempty" tf:"bucket_name,omitempty"`

	// Identifier of the certificate to bind to.
	CertificateID *string `json:"certificateId,omitempty" tf:"certificate_id,omitempty"`

	// The exported class name of the Durable Object.
	ClassName *string `json:"className,omitempty" tf:"class_name,omitempty"`

	// The name of the dataset to bind to.
	Dataset *string `json:"dataset,omitempty" tf:"dataset,omitempty"`

	// Destination address for the email.
	DestinationAddress *string `json:"destinationAddress,omitempty" tf:"destination_address,omitempty"`

	// The environment of the script_name to bind to.
	Environment *string `json:"environment,omitempty" tf:"environment,omitempty"`

	// Data format of the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#format).
	// Available values: "raw", "pkcs8", "spki", "jwk".
	Format *string `json:"format,omitempty" tf:"format,omitempty"`

	// Identifier of the D1 database to bind to.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Name of the Vectorize index to bind to.
	IndexName *string `json:"indexName,omitempty" tf:"index_name,omitempty"`

	// JSON data to use.
	JSON *string `json:"json,omitempty" tf:"json,omitempty"`

	// The [jurisdiction](https://developers.cloudflare.com/r2/reference/data-location/#jurisdictional-restrictions) of the R2 bucket.
	// Available values: "eu", "fedramp".
	Jurisdiction *string `json:"jurisdiction,omitempty" tf:"jurisdiction,omitempty"`

	// A JavaScript variable name for the binding.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The name of the dispatch namespace.
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// Namespace identifier tag.
	NamespaceID *string `json:"namespaceId,omitempty" tf:"namespace_id,omitempty"`

	// The old name of the inherited binding. If set, the binding will be renamed from `old_name` to `name` in the new version. If not set, the binding will keep the same name between versions.
	OldName *string `json:"oldName,omitempty" tf:"old_name,omitempty"`

	Outbound *OutboundObservation `json:"outbound,omitempty" tf:"outbound,omitempty"`

	// The name of the file containing the data content. Only accepted for `service worker syntax` Workers.
	Part *string `json:"part,omitempty" tf:"part,omitempty"`

	// Name of the Pipeline to bind to.
	Pipeline *string `json:"pipeline,omitempty" tf:"pipeline,omitempty"`

	// Name of the Queue to bind to.
	QueueName *string `json:"queueName,omitempty" tf:"queue_name,omitempty"`

	// The script where the Durable Object is defined, if it is external to this Worker.
	ScriptName *string `json:"scriptName,omitempty" tf:"script_name,omitempty"`

	// Name of the secret in the store.
	SecretName *string `json:"secretName,omitempty" tf:"secret_name,omitempty"`

	// Name of Worker to bind to.
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// ID of the store containing the secret.
	StoreID *string `json:"storeId,omitempty" tf:"store_id,omitempty"`

	// The kind of resource that the binding provides.
	// Available values: "ai", "analytics_engine", "assets", "browser", "d1", "data_blob", "dispatch_namespace", "durable_object_namespace", "hyperdrive", "inherit", "images", "json", "kv_namespace", "mtls_certificate", "plain_text", "pipelines", "queue", "r2_bucket", "secret_text", "send_email", "service", "tail_consumer", "text_blob", "vectorize", "version_metadata", "secrets_store_secret", "secret_key", "workflow", "wasm_module".
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Allowed operations with the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#keyUsages).
	// +listType=set
	Usages []*string `json:"usages,omitempty" tf:"usages,omitempty"`

	// Identifier for the version to inherit the binding from, which can be the version ID or the literal "latest" to inherit from the latest version. Defaults to inheriting the binding from the latest version.
	VersionID *string `json:"versionId,omitempty" tf:"version_id,omitempty"`

	// Name of the Workflow to bind to.
	WorkflowName *string `json:"workflowName,omitempty" tf:"workflow_name,omitempty"`
}

type BindingsParameters struct {

	// Algorithm-specific key parameters. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#algorithm).
	// +kubebuilder:validation:Optional
	Algorithm *string `json:"algorithm,omitempty" tf:"algorithm,omitempty"`

	// List of allowed destination addresses.
	// +kubebuilder:validation:Optional
	AllowedDestinationAddresses []*string `json:"allowedDestinationAddresses,omitempty" tf:"allowed_destination_addresses,omitempty"`

	// List of allowed sender addresses.
	// +kubebuilder:validation:Optional
	AllowedSenderAddresses []*string `json:"allowedSenderAddresses,omitempty" tf:"allowed_sender_addresses,omitempty"`

	// R2 bucket to bind to.
	// +kubebuilder:validation:Optional
	BucketName *string `json:"bucketName,omitempty" tf:"bucket_name,omitempty"`

	// Identifier of the certificate to bind to.
	// +kubebuilder:validation:Optional
	CertificateID *string `json:"certificateId,omitempty" tf:"certificate_id,omitempty"`

	// The exported class name of the Durable Object.
	// +kubebuilder:validation:Optional
	ClassName *string `json:"className,omitempty" tf:"class_name,omitempty"`

	// The name of the dataset to bind to.
	// +kubebuilder:validation:Optional
	Dataset *string `json:"dataset,omitempty" tf:"dataset,omitempty"`

	// Destination address for the email.
	// +kubebuilder:validation:Optional
	DestinationAddress *string `json:"destinationAddress,omitempty" tf:"destination_address,omitempty"`

	// The environment of the script_name to bind to.
	// +kubebuilder:validation:Optional
	Environment *string `json:"environment,omitempty" tf:"environment,omitempty"`

	// Data format of the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#format).
	// Available values: "raw", "pkcs8", "spki", "jwk".
	// +kubebuilder:validation:Optional
	Format *string `json:"format,omitempty" tf:"format,omitempty"`

	// Identifier of the D1 database to bind to.
	// +kubebuilder:validation:Optional
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Name of the Vectorize index to bind to.
	// +kubebuilder:validation:Optional
	IndexName *string `json:"indexName,omitempty" tf:"index_name,omitempty"`

	// JSON data to use.
	// +kubebuilder:validation:Optional
	JSON *string `json:"json,omitempty" tf:"json,omitempty"`

	// The [jurisdiction](https://developers.cloudflare.com/r2/reference/data-location/#jurisdictional-restrictions) of the R2 bucket.
	// Available values: "eu", "fedramp".
	// +kubebuilder:validation:Optional
	Jurisdiction *string `json:"jurisdiction,omitempty" tf:"jurisdiction,omitempty"`

	// Base64-encoded key data. Required if `format` is "raw", "pkcs8", or "spki".
	// +kubebuilder:validation:Optional
	KeyBase64SecretRef *v1.SecretKeySelector `json:"keyBase64SecretRef,omitempty" tf:"-"`

	// Key data in [JSON Web Key](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#json_web_key) format. Required if `format` is "jwk".
	// +kubebuilder:validation:Optional
	KeyJwkSecretRef *v1.SecretKeySelector `json:"keyJwkSecretRef,omitempty" tf:"-"`

	// A JavaScript variable name for the binding.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// The name of the dispatch namespace.
	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// Namespace identifier tag.
	// +kubebuilder:validation:Optional
	NamespaceID *string `json:"namespaceId,omitempty" tf:"namespace_id,omitempty"`

	// The old name of the inherited binding. If set, the binding will be renamed from `old_name` to `name` in the new version. If not set, the binding will keep the same name between versions.
	// +kubebuilder:validation:Optional
	OldName *string `json:"oldName,omitempty" tf:"old_name,omitempty"`

	// +kubebuilder:validation:Optional
	Outbound *OutboundParameters `json:"outbound,omitempty" tf:"outbound,omitempty"`

	// The name of the file containing the data content. Only accepted for `service worker syntax` Workers.
	// +kubebuilder:validation:Optional
	Part *string `json:"part,omitempty" tf:"part,omitempty"`

	// Name of the Pipeline to bind to.
	// +kubebuilder:validation:Optional
	Pipeline *string `json:"pipeline,omitempty" tf:"pipeline,omitempty"`

	// Name of the Queue to bind to.
	// +kubebuilder:validation:Optional
	QueueName *string `json:"queueName,omitempty" tf:"queue_name,omitempty"`

	// The script where the Durable Object is defined, if it is external to this Worker.
	// +kubebuilder:validation:Optional
	ScriptName *string `json:"scriptName,omitempty" tf:"script_name,omitempty"`

	// Name of the secret in the store.
	// +kubebuilder:validation:Optional
	SecretName *string `json:"secretName,omitempty" tf:"secret_name,omitempty"`

	// Name of Worker to bind to.
	// +kubebuilder:validation:Optional
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// ID of the store containing the secret.
	// +kubebuilder:validation:Optional
	StoreID *string `json:"storeId,omitempty" tf:"store_id,omitempty"`

	// The text value to use.
	// +kubebuilder:validation:Optional
	TextSecretRef *v1.SecretKeySelector `json:"textSecretRef,omitempty" tf:"-"`

	// The kind of resource that the binding provides.
	// Available values: "ai", "analytics_engine", "assets", "browser", "d1", "data_blob", "dispatch_namespace", "durable_object_namespace", "hyperdrive", "inherit", "images", "json", "kv_namespace", "mtls_certificate", "plain_text", "pipelines", "queue", "r2_bucket", "secret_text", "send_email", "service", "tail_consumer", "text_blob", "vectorize", "version_metadata", "secrets_store_secret", "secret_key", "workflow", "wasm_module".
	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`

	// Allowed operations with the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#keyUsages).
	// +kubebuilder:validation:Optional
	// +listType=set
	Usages []*string `json:"usages,omitempty" tf:"usages,omitempty"`

	// Identifier for the version to inherit the binding from, which can be the version ID or the literal "latest" to inherit from the latest version. Defaults to inheriting the binding from the latest version.
	// +kubebuilder:validation:Optional
	VersionID *string `json:"versionId,omitempty" tf:"version_id,omitempty"`

	// Name of the Workflow to bind to.
	// +kubebuilder:validation:Optional
	WorkflowName *string `json:"workflowName,omitempty" tf:"workflow_name,omitempty"`
}

type ConfigInitParameters struct {

	// Determines the redirects and rewrites of requests for HTML content.
	// Available values: "auto-trailing-slash", "force-trailing-slash", "drop-trailing-slash", "none".
	HTMLHandling *string `json:"htmlHandling,omitempty" tf:"html_handling,omitempty"`

	// The contents of a _headers file (used to attach custom headers on asset responses).
	Headers *string `json:"headers,omitempty" tf:"headers,omitempty"`

	// Determines the response when a request does not match a static asset, and there is no Worker script.
	// Available values: "none", "404-page", "single-page-application".
	NotFoundHandling *string `json:"notFoundHandling,omitempty" tf:"not_found_handling,omitempty"`

	// The contents of a _redirects file (used to apply redirects or proxy paths ahead of asset serving).
	Redirects *string `json:"redirects,omitempty" tf:"redirects,omitempty"`

	// When a boolean true, requests will always invoke the Worker script. Otherwise, attempt to serve an asset matching the request, falling back to the Worker script. When a list of strings, contains path rules to control routing to either the Worker or assets. Glob (*) and negative (!) rules are supported. Rules must start with either '/' or '!/'. At least one non-negative rule must be provided, and negative rules have higher precedence than non-negative rules.
	RunWorkerFirst *v1apiextensions.JSON `json:"runWorkerFirst,omitempty" tf:"run_worker_first,omitempty"`

	// When true and the incoming request matches an asset, that will be served instead of invoking the Worker script. When false, requests will always invoke the Worker script.
	ServeDirectly *bool `json:"serveDirectly,omitempty" tf:"serve_directly,omitempty"`
}

type ConfigObservation struct {

	// Determines the redirects and rewrites of requests for HTML content.
	// Available values: "auto-trailing-slash", "force-trailing-slash", "drop-trailing-slash", "none".
	HTMLHandling *string `json:"htmlHandling,omitempty" tf:"html_handling,omitempty"`

	// The contents of a _headers file (used to attach custom headers on asset responses).
	Headers *string `json:"headers,omitempty" tf:"headers,omitempty"`

	// Determines the response when a request does not match a static asset, and there is no Worker script.
	// Available values: "none", "404-page", "single-page-application".
	NotFoundHandling *string `json:"notFoundHandling,omitempty" tf:"not_found_handling,omitempty"`

	// The contents of a _redirects file (used to apply redirects or proxy paths ahead of asset serving).
	Redirects *string `json:"redirects,omitempty" tf:"redirects,omitempty"`

	// When a boolean true, requests will always invoke the Worker script. Otherwise, attempt to serve an asset matching the request, falling back to the Worker script. When a list of strings, contains path rules to control routing to either the Worker or assets. Glob (*) and negative (!) rules are supported. Rules must start with either '/' or '!/'. At least one non-negative rule must be provided, and negative rules have higher precedence than non-negative rules.
	RunWorkerFirst *v1apiextensions.JSON `json:"runWorkerFirst,omitempty" tf:"run_worker_first,omitempty"`

	// When true and the incoming request matches an asset, that will be served instead of invoking the Worker script. When false, requests will always invoke the Worker script.
	ServeDirectly *bool `json:"serveDirectly,omitempty" tf:"serve_directly,omitempty"`
}

type ConfigParameters struct {

	// Determines the redirects and rewrites of requests for HTML content.
	// Available values: "auto-trailing-slash", "force-trailing-slash", "drop-trailing-slash", "none".
	// +kubebuilder:validation:Optional
	HTMLHandling *string `json:"htmlHandling,omitempty" tf:"html_handling,omitempty"`

	// The contents of a _headers file (used to attach custom headers on asset responses).
	// +kubebuilder:validation:Optional
	Headers *string `json:"headers,omitempty" tf:"headers,omitempty"`

	// Determines the response when a request does not match a static asset, and there is no Worker script.
	// Available values: "none", "404-page", "single-page-application".
	// +kubebuilder:validation:Optional
	NotFoundHandling *string `json:"notFoundHandling,omitempty" tf:"not_found_handling,omitempty"`

	// The contents of a _redirects file (used to apply redirects or proxy paths ahead of asset serving).
	// +kubebuilder:validation:Optional
	Redirects *string `json:"redirects,omitempty" tf:"redirects,omitempty"`

	// When a boolean true, requests will always invoke the Worker script. Otherwise, attempt to serve an asset matching the request, falling back to the Worker script. When a list of strings, contains path rules to control routing to either the Worker or assets. Glob (*) and negative (!) rules are supported. Rules must start with either '/' or '!/'. At least one non-negative rule must be provided, and negative rules have higher precedence than non-negative rules.
	// +kubebuilder:validation:Optional
	RunWorkerFirst *v1apiextensions.JSON `json:"runWorkerFirst,omitempty" tf:"run_worker_first,omitempty"`

	// When true and the incoming request matches an asset, that will be served instead of invoking the Worker script. When false, requests will always invoke the Worker script.
	// +kubebuilder:validation:Optional
	ServeDirectly *bool `json:"serveDirectly,omitempty" tf:"serve_directly,omitempty"`
}

type LimitsInitParameters struct {

	// The amount of CPU time this Worker can use in milliseconds.
	CPUMs *float64 `json:"cpuMs,omitempty" tf:"cpu_ms,omitempty"`
}

type LimitsObservation struct {

	// The amount of CPU time this Worker can use in milliseconds.
	CPUMs *float64 `json:"cpuMs,omitempty" tf:"cpu_ms,omitempty"`
}

type LimitsParameters struct {

	// The amount of CPU time this Worker can use in milliseconds.
	// +kubebuilder:validation:Optional
	CPUMs *float64 `json:"cpuMs,omitempty" tf:"cpu_ms,omitempty"`
}

type LogsInitParameters struct {

	// A list of destinations where logs will be exported to.
	Destinations []*string `json:"destinations,omitempty" tf:"destinations,omitempty"`

	// Whether logs are enabled for the Worker.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The sampling rate for logs. From 0 to 1 (1 = 100%, 0.1 = 10%). Default is 1.
	HeadSamplingRate *float64 `json:"headSamplingRate,omitempty" tf:"head_sampling_rate,omitempty"`

	// Whether [invocation logs](https://developers.cloudflare.com/workers/observability/logs/workers-logs/#invocation-logs) are enabled for the Worker.
	InvocationLogs *bool `json:"invocationLogs,omitempty" tf:"invocation_logs,omitempty"`

	// Whether log persistence is enabled for the Worker.
	Persist *bool `json:"persist,omitempty" tf:"persist,omitempty"`
}

type LogsObservation struct {

	// A list of destinations where logs will be exported to.
	Destinations []*string `json:"destinations,omitempty" tf:"destinations,omitempty"`

	// Whether logs are enabled for the Worker.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The sampling rate for logs. From 0 to 1 (1 = 100%, 0.1 = 10%). Default is 1.
	HeadSamplingRate *float64 `json:"headSamplingRate,omitempty" tf:"head_sampling_rate,omitempty"`

	// Whether [invocation logs](https://developers.cloudflare.com/workers/observability/logs/workers-logs/#invocation-logs) are enabled for the Worker.
	InvocationLogs *bool `json:"invocationLogs,omitempty" tf:"invocation_logs,omitempty"`

	// Whether log persistence is enabled for the Worker.
	Persist *bool `json:"persist,omitempty" tf:"persist,omitempty"`
}

type LogsParameters struct {

	// A list of destinations where logs will be exported to.
	// +kubebuilder:validation:Optional
	Destinations []*string `json:"destinations,omitempty" tf:"destinations,omitempty"`

	// Whether logs are enabled for the Worker.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled" tf:"enabled,omitempty"`

	// The sampling rate for logs. From 0 to 1 (1 = 100%, 0.1 = 10%). Default is 1.
	// +kubebuilder:validation:Optional
	HeadSamplingRate *float64 `json:"headSamplingRate,omitempty" tf:"head_sampling_rate,omitempty"`

	// Whether [invocation logs](https://developers.cloudflare.com/workers/observability/logs/workers-logs/#invocation-logs) are enabled for the Worker.
	// +kubebuilder:validation:Optional
	InvocationLogs *bool `json:"invocationLogs" tf:"invocation_logs,omitempty"`

	// Whether log persistence is enabled for the Worker.
	// +kubebuilder:validation:Optional
	Persist *bool `json:"persist,omitempty" tf:"persist,omitempty"`
}

type MigrationsInitParameters struct {

	// A list of classes to delete Durable Object namespaces from.
	DeletedClasses []*string `json:"deletedClasses,omitempty" tf:"deleted_classes,omitempty"`

	// A list of classes to create Durable Object namespaces from.
	NewClasses []*string `json:"newClasses,omitempty" tf:"new_classes,omitempty"`

	// A list of classes to create Durable Object namespaces with SQLite from.
	NewSqliteClasses []*string `json:"newSqliteClasses,omitempty" tf:"new_sqlite_classes,omitempty"`

	// Tag to set as the latest migration tag.
	NewTag *string `json:"newTag,omitempty" tf:"new_tag,omitempty"`

	// Tag used to verify against the latest migration tag for this Worker. If they don't match, the upload is rejected.
	OldTag *string `json:"oldTag,omitempty" tf:"old_tag,omitempty"`

	RenamedClasses []RenamedClassesInitParameters `json:"renamedClasses,omitempty" tf:"renamed_classes,omitempty"`

	Steps []StepsInitParameters `json:"steps,omitempty" tf:"steps,omitempty"`

	TransferredClasses []MigrationsTransferredClassesInitParameters `json:"transferredClasses,omitempty" tf:"transferred_classes,omitempty"`
}

type MigrationsObservation struct {

	// A list of classes to delete Durable Object namespaces from.
	DeletedClasses []*string `json:"deletedClasses,omitempty" tf:"deleted_classes,omitempty"`

	// A list of classes to create Durable Object namespaces from.
	NewClasses []*string `json:"newClasses,omitempty" tf:"new_classes,omitempty"`

	// A list of classes to create Durable Object namespaces with SQLite from.
	NewSqliteClasses []*string `json:"newSqliteClasses,omitempty" tf:"new_sqlite_classes,omitempty"`

	// Tag to set as the latest migration tag.
	NewTag *string `json:"newTag,omitempty" tf:"new_tag,omitempty"`

	// Tag used to verify against the latest migration tag for this Worker. If they don't match, the upload is rejected.
	OldTag *string `json:"oldTag,omitempty" tf:"old_tag,omitempty"`

	RenamedClasses []RenamedClassesObservation `json:"renamedClasses,omitempty" tf:"renamed_classes,omitempty"`

	Steps []StepsObservation `json:"steps,omitempty" tf:"steps,omitempty"`

	TransferredClasses []MigrationsTransferredClassesObservation `json:"transferredClasses,omitempty" tf:"transferred_classes,omitempty"`
}

type MigrationsParameters struct {

	// A list of classes to delete Durable Object namespaces from.
	// +kubebuilder:validation:Optional
	DeletedClasses []*string `json:"deletedClasses,omitempty" tf:"deleted_classes,omitempty"`

	// A list of classes to create Durable Object namespaces from.
	// +kubebuilder:validation:Optional
	NewClasses []*string `json:"newClasses,omitempty" tf:"new_classes,omitempty"`

	// A list of classes to create Durable Object namespaces with SQLite from.
	// +kubebuilder:validation:Optional
	NewSqliteClasses []*string `json:"newSqliteClasses,omitempty" tf:"new_sqlite_classes,omitempty"`

	// Tag to set as the latest migration tag.
	// +kubebuilder:validation:Optional
	NewTag *string `json:"newTag,omitempty" tf:"new_tag,omitempty"`

	// Tag used to verify against the latest migration tag for this Worker. If they don't match, the upload is rejected.
	// +kubebuilder:validation:Optional
	OldTag *string `json:"oldTag,omitempty" tf:"old_tag,omitempty"`

	// +kubebuilder:validation:Optional
	RenamedClasses []RenamedClassesParameters `json:"renamedClasses,omitempty" tf:"renamed_classes,omitempty"`

	// +kubebuilder:validation:Optional
	Steps []StepsParameters `json:"steps,omitempty" tf:"steps,omitempty"`

	// +kubebuilder:validation:Optional
	TransferredClasses []MigrationsTransferredClassesParameters `json:"transferredClasses,omitempty" tf:"transferred_classes,omitempty"`
}

type MigrationsTransferredClassesInitParameters struct {
	From *string `json:"from,omitempty" tf:"from,omitempty"`

	FromScript *string `json:"fromScript,omitempty" tf:"from_script,omitempty"`

	To *string `json:"to,omitempty" tf:"to,omitempty"`
}

type MigrationsTransferredClassesObservation struct {
	From *string `json:"from,omitempty" tf:"from,omitempty"`

	FromScript *string `json:"fromScript,omitempty" tf:"from_script,omitempty"`

	To *string `json:"to,omitempty" tf:"to,omitempty"`
}

type MigrationsTransferredClassesParameters struct {

	// +kubebuilder:validation:Optional
	From *string `json:"from,omitempty" tf:"from,omitempty"`

	// +kubebuilder:validation:Optional
	FromScript *string `json:"fromScript,omitempty" tf:"from_script,omitempty"`

	// +kubebuilder:validation:Optional
	To *string `json:"to,omitempty" tf:"to,omitempty"`
}

type NamedHandlersInitParameters struct {
}

type NamedHandlersObservation struct {

	// The names of handlers exported as part of the named export.
	Handlers []*string `json:"handlers,omitempty" tf:"handlers,omitempty"`

	// The name of the export.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type NamedHandlersParameters struct {
}

type ObservabilityInitParameters struct {

	// Whether observability is enabled for the Worker.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The sampling rate for incoming requests. From 0 to 1 (1 = 100%, 0.1 = 10%). Default is 1.
	HeadSamplingRate *float64 `json:"headSamplingRate,omitempty" tf:"head_sampling_rate,omitempty"`

	Logs *LogsInitParameters `json:"logs,omitempty" tf:"logs,omitempty"`
}

type ObservabilityObservation struct {

	// Whether observability is enabled for the Worker.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The sampling rate for incoming requests. From 0 to 1 (1 = 100%, 0.1 = 10%). Default is 1.
	HeadSamplingRate *float64 `json:"headSamplingRate,omitempty" tf:"head_sampling_rate,omitempty"`

	Logs *LogsObservation `json:"logs,omitempty" tf:"logs,omitempty"`
}

type ObservabilityParameters struct {

	// Whether observability is enabled for the Worker.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled" tf:"enabled,omitempty"`

	// The sampling rate for incoming requests. From 0 to 1 (1 = 100%, 0.1 = 10%). Default is 1.
	// +kubebuilder:validation:Optional
	HeadSamplingRate *float64 `json:"headSamplingRate,omitempty" tf:"head_sampling_rate,omitempty"`

	// +kubebuilder:validation:Optional
	Logs *LogsParameters `json:"logs,omitempty" tf:"logs,omitempty"`
}

type OutboundInitParameters struct {

	// Pass information from the Dispatch Worker to the Outbound Worker through the parameters.
	Params []*string `json:"params,omitempty" tf:"params,omitempty"`

	Worker *WorkerInitParameters `json:"worker,omitempty" tf:"worker,omitempty"`
}

type OutboundObservation struct {

	// Pass information from the Dispatch Worker to the Outbound Worker through the parameters.
	Params []*string `json:"params,omitempty" tf:"params,omitempty"`

	Worker *WorkerObservation `json:"worker,omitempty" tf:"worker,omitempty"`
}

type OutboundParameters struct {

	// Pass information from the Dispatch Worker to the Outbound Worker through the parameters.
	// +kubebuilder:validation:Optional
	Params []*string `json:"params,omitempty" tf:"params,omitempty"`

	// +kubebuilder:validation:Optional
	Worker *WorkerParameters `json:"worker,omitempty" tf:"worker,omitempty"`
}

type PlacementInitParameters struct {

	// Enables [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
	// Available values: "smart".
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`
}

type PlacementObservation struct {

	// TCP host and port for targeted placement.
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// HTTP hostname for targeted placement.
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	// The last time the script was analyzed for [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
	LastAnalyzedAt *string `json:"lastAnalyzedAt,omitempty" tf:"last_analyzed_at,omitempty"`

	// Enables [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
	// Available values: "smart".
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// Cloud region for targeted placement in format 'provider:region'.
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// Status of [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
	// Available values: "SUCCESS", "UNSUPPORTED_APPLICATION", "INSUFFICIENT_INVOCATIONS".
	Status *string `json:"status,omitempty" tf:"status,omitempty"`
}

type PlacementParameters struct {

	// Enables [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
	// Available values: "smart".
	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`
}

type RenamedClassesInitParameters struct {
	From *string `json:"from,omitempty" tf:"from,omitempty"`

	To *string `json:"to,omitempty" tf:"to,omitempty"`
}

type RenamedClassesObservation struct {
	From *string `json:"from,omitempty" tf:"from,omitempty"`

	To *string `json:"to,omitempty" tf:"to,omitempty"`
}

type RenamedClassesParameters struct {

	// +kubebuilder:validation:Optional
	From *string `json:"from,omitempty" tf:"from,omitempty"`

	// +kubebuilder:validation:Optional
	To *string `json:"to,omitempty" tf:"to,omitempty"`
}

type ScriptInitParameters struct {

	// Identifier.
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	Assets *AssetsInitParameters `json:"assets,omitempty" tf:"assets,omitempty"`

	Bindings []BindingsInitParameters `json:"bindings,omitempty" tf:"bindings,omitempty"`

	// Name of the uploaded file that contains the script (e.g. the file adding a listener to the `fetch` event). Indicates a `service worker syntax` Worker.
	BodyPart *string `json:"bodyPart,omitempty" tf:"body_part,omitempty"`

	// Date indicating targeted support in the Workers runtime. Backwards incompatible fixes to the runtime following this date will not affect this Worker.
	CompatibilityDate *string `json:"compatibilityDate,omitempty" tf:"compatibility_date,omitempty"`

	// Flags that enable or disable certain features in the Workers runtime. Used to enable upcoming features or opt in or out of specific changes not included in a `compatibility_date`.
	// +listType=set
	CompatibilityFlags []*string `json:"compatibilityFlags,omitempty" tf:"compatibility_flags,omitempty"`

	// Module or Service Worker contents of the Worker. Conflicts with `content_file`.
	Content *string `json:"content,omitempty" tf:"content,omitempty"`

	// Path to a file containing the Module or Service Worker contents of the Worker. Conflicts with `content`. Must be paired with `content_sha256`.
	ContentFile *string `json:"contentFile,omitempty" tf:"content_file,omitempty"`

	// SHA-256 hash of the Worker contents. Used to trigger updates when source code changes. Must be provided when `content_file` is specified.
	ContentSha256 *string `json:"contentSha256,omitempty" tf:"content_sha256,omitempty"`

	// Content-Type of the Worker. Required if uploading a non-JavaScript Worker (e.g. "text/x-python").
	ContentType *string `json:"contentType,omitempty" tf:"content_type,omitempty"`

	// Retain assets which exist for a previously uploaded Worker version; used in lieu of providing a completion token.
	KeepAssets *bool `json:"keepAssets,omitempty" tf:"keep_assets,omitempty"`

	// List of binding types to keep from previous_upload.
	// +listType=set
	KeepBindings []*string `json:"keepBindings,omitempty" tf:"keep_bindings,omitempty"`

	Limits *LimitsInitParameters `json:"limits,omitempty" tf:"limits,omitempty"`

	// Whether Logpush is turned on for the Worker.
	Logpush *bool `json:"logpush,omitempty" tf:"logpush,omitempty"`

	// Name of the uploaded file that contains the main module (e.g. the file exporting a `fetch` handler). Indicates a `module syntax` Worker.
	MainModule *string `json:"mainModule,omitempty" tf:"main_module,omitempty"`

	Migrations *MigrationsInitParameters `json:"migrations,omitempty" tf:"migrations,omitempty"`

	Observability *ObservabilityInitParameters `json:"observability,omitempty" tf:"observability,omitempty"`

	Placement *PlacementInitParameters `json:"placement,omitempty" tf:"placement,omitempty"`

	// Name of the script, used in URLs and route configuration.
	ScriptName *string `json:"scriptName,omitempty" tf:"script_name,omitempty"`

	TailConsumers []TailConsumersInitParameters `json:"tailConsumers,omitempty" tf:"tail_consumers,omitempty"`

	// Usage model for the Worker invocations.
	// Available values: "standard", "bundled", "unbound".
	UsageModel *string `json:"usageModel,omitempty" tf:"usage_model,omitempty"`
}

type ScriptObservation struct {

	// Identifier.
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	Assets *AssetsObservation `json:"assets,omitempty" tf:"assets,omitempty"`

	Bindings []BindingsObservation `json:"bindings,omitempty" tf:"bindings,omitempty"`

	// Name of the uploaded file that contains the script (e.g. the file adding a listener to the `fetch` event). Indicates a `service worker syntax` Worker.
	BodyPart *string `json:"bodyPart,omitempty" tf:"body_part,omitempty"`

	// Date indicating targeted support in the Workers runtime. Backwards incompatible fixes to the runtime following this date will not affect this Worker.
	CompatibilityDate *string `json:"compatibilityDate,omitempty" tf:"compatibility_date,omitempty"`

	// Flags that enable or disable certain features in the Workers runtime. Used to enable upcoming features or opt in or out of specific changes not included in a `compatibility_date`.
	// +listType=set
	CompatibilityFlags []*string `json:"compatibilityFlags,omitempty" tf:"compatibility_flags,omitempty"`

	// Module or Service Worker contents of the Worker. Conflicts with `content_file`.
	Content *string `json:"content,omitempty" tf:"content,omitempty"`

	// Path to a file containing the Module or Service Worker contents of the Worker. Conflicts with `content`. Must be paired with `content_sha256`.
	ContentFile *string `json:"contentFile,omitempty" tf:"content_file,omitempty"`

	// SHA-256 hash of the Worker contents. Used to trigger updates when source code changes. Must be provided when `content_file` is specified.
	ContentSha256 *string `json:"contentSha256,omitempty" tf:"content_sha256,omitempty"`

	// Content-Type of the Worker. Required if uploading a non-JavaScript Worker (e.g. "text/x-python").
	ContentType *string `json:"contentType,omitempty" tf:"content_type,omitempty"`

	// When the script was created.
	CreatedOn *string `json:"createdOn,omitempty" tf:"created_on,omitempty"`

	// Hashed script content, can be used in a If-None-Match header when updating.
	Etag *string `json:"etag,omitempty" tf:"etag,omitempty"`

	// The names of handlers exported as part of the default export.
	Handlers []*string `json:"handlers,omitempty" tf:"handlers,omitempty"`

	// Whether a Worker contains assets.
	HasAssets *bool `json:"hasAssets,omitempty" tf:"has_assets,omitempty"`

	// Whether a Worker contains modules.
	HasModules *bool `json:"hasModules,omitempty" tf:"has_modules,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Retain assets which exist for a previously uploaded Worker version; used in lieu of providing a completion token.
	KeepAssets *bool `json:"keepAssets,omitempty" tf:"keep_assets,omitempty"`

	// List of binding types to keep from previous_upload.
	// +listType=set
	KeepBindings []*string `json:"keepBindings,omitempty" tf:"keep_bindings,omitempty"`

	// The client most recently used to deploy this Worker.
	LastDeployedFrom *string `json:"lastDeployedFrom,omitempty" tf:"last_deployed_from,omitempty"`

	Limits *LimitsObservation `json:"limits,omitempty" tf:"limits,omitempty"`

	// Whether Logpush is turned on for the Worker.
	Logpush *bool `json:"logpush,omitempty" tf:"logpush,omitempty"`

	// Name of the uploaded file that contains the main module (e.g. the file exporting a `fetch` handler). Indicates a `module syntax` Worker.
	MainModule *string `json:"mainModule,omitempty" tf:"main_module,omitempty"`

	// The tag of the Durable Object migration that was most recently applied for this Worker.
	MigrationTag *string `json:"migrationTag,omitempty" tf:"migration_tag,omitempty"`

	Migrations *MigrationsObservation `json:"migrations,omitempty" tf:"migrations,omitempty"`

	// When the script was last modified.
	ModifiedOn *string `json:"modifiedOn,omitempty" tf:"modified_on,omitempty"`

	NamedHandlers []NamedHandlersObservation `json:"namedHandlers,omitempty" tf:"named_handlers,omitempty"`

	Observability *ObservabilityObservation `json:"observability,omitempty" tf:"observability,omitempty"`

	Placement *PlacementObservation `json:"placement,omitempty" tf:"placement,omitempty"`

	// Name of the script, used in URLs and route configuration.
	ScriptName *string `json:"scriptName,omitempty" tf:"script_name,omitempty"`

	StartupTimeMs *float64 `json:"startupTimeMs,omitempty" tf:"startup_time_ms,omitempty"`

	TailConsumers []TailConsumersObservation `json:"tailConsumers,omitempty" tf:"tail_consumers,omitempty"`

	// Usage model for the Worker invocations.
	// Available values: "standard", "bundled", "unbound".
	UsageModel *string `json:"usageModel,omitempty" tf:"usage_model,omitempty"`
}

type ScriptParameters struct {

	// Identifier.
	// +kubebuilder:validation:Optional
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	// +kubebuilder:validation:Optional
	Assets *AssetsParameters `json:"assets,omitempty" tf:"assets,omitempty"`

	// +kubebuilder:validation:Optional
	Bindings []BindingsParameters `json:"bindings,omitempty" tf:"bindings,omitempty"`

	// Name of the uploaded file that contains the script (e.g. the file adding a listener to the `fetch` event). Indicates a `service worker syntax` Worker.
	// +kubebuilder:validation:Optional
	BodyPart *string `json:"bodyPart,omitempty" tf:"body_part,omitempty"`

	// Date indicating targeted support in the Workers runtime. Backwards incompatible fixes to the runtime following this date will not affect this Worker.
	// +kubebuilder:validation:Optional
	CompatibilityDate *string `json:"compatibilityDate,omitempty" tf:"compatibility_date,omitempty"`

	// Flags that enable or disable certain features in the Workers runtime. Used to enable upcoming features or opt in or out of specific changes not included in a `compatibility_date`.
	// +kubebuilder:validation:Optional
	// +listType=set
	CompatibilityFlags []*string `json:"compatibilityFlags,omitempty" tf:"compatibility_flags,omitempty"`

	// Module or Service Worker contents of the Worker. Conflicts with `content_file`.
	// +kubebuilder:validation:Optional
	Content *string `json:"content,omitempty" tf:"content,omitempty"`

	// Path to a file containing the Module or Service Worker contents of the Worker. Conflicts with `content`. Must be paired with `content_sha256`.
	// +kubebuilder:validation:Optional
	ContentFile *string `json:"contentFile,omitempty" tf:"content_file,omitempty"`

	// SHA-256 hash of the Worker contents. Used to trigger updates when source code changes. Must be provided when `content_file` is specified.
	// +kubebuilder:validation:Optional
	ContentSha256 *string `json:"contentSha256,omitempty" tf:"content_sha256,omitempty"`

	// Content-Type of the Worker. Required if uploading a non-JavaScript Worker (e.g. "text/x-python").
	// +kubebuilder:validation:Optional
	ContentType *string `json:"contentType,omitempty" tf:"content_type,omitempty"`

	// Retain assets which exist for a previously uploaded Worker version; used in lieu of providing a completion token.
	// +kubebuilder:validation:Optional
	KeepAssets *bool `json:"keepAssets,omitempty" tf:"keep_assets,omitempty"`

	// List of binding types to keep from previous_upload.
	// +kubebuilder:validation:Optional
	// +listType=set
	KeepBindings []*string `json:"keepBindings,omitempty" tf:"keep_bindings,omitempty"`

	// +kubebuilder:validation:Optional
	Limits *LimitsParameters `json:"limits,omitempty" tf:"limits,omitempty"`

	// Whether Logpush is turned on for the Worker.
	// +kubebuilder:validation:Optional
	Logpush *bool `json:"logpush,omitempty" tf:"logpush,omitempty"`

	// Name of the uploaded file that contains the main module (e.g. the file exporting a `fetch` handler). Indicates a `module syntax` Worker.
	// +kubebuilder:validation:Optional
	MainModule *string `json:"mainModule,omitempty" tf:"main_module,omitempty"`

	// +kubebuilder:validation:Optional
	Migrations *MigrationsParameters `json:"migrations,omitempty" tf:"migrations,omitempty"`

	// +kubebuilder:validation:Optional
	Observability *ObservabilityParameters `json:"observability,omitempty" tf:"observability,omitempty"`

	// +kubebuilder:validation:Optional
	Placement *PlacementParameters `json:"placement,omitempty" tf:"placement,omitempty"`

	// Name of the script, used in URLs and route configuration.
	// +kubebuilder:validation:Optional
	ScriptName *string `json:"scriptName,omitempty" tf:"script_name,omitempty"`

	// +kubebuilder:validation:Optional
	TailConsumers []TailConsumersParameters `json:"tailConsumers,omitempty" tf:"tail_consumers,omitempty"`

	// Usage model for the Worker invocations.
	// Available values: "standard", "bundled", "unbound".
	// +kubebuilder:validation:Optional
	UsageModel *string `json:"usageModel,omitempty" tf:"usage_model,omitempty"`
}

type StepsInitParameters struct {

	// A list of classes to delete Durable Object namespaces from.
	DeletedClasses []*string `json:"deletedClasses,omitempty" tf:"deleted_classes,omitempty"`

	// A list of classes to create Durable Object namespaces from.
	NewClasses []*string `json:"newClasses,omitempty" tf:"new_classes,omitempty"`

	// A list of classes to create Durable Object namespaces with SQLite from.
	NewSqliteClasses []*string `json:"newSqliteClasses,omitempty" tf:"new_sqlite_classes,omitempty"`

	RenamedClasses []StepsRenamedClassesInitParameters `json:"renamedClasses,omitempty" tf:"renamed_classes,omitempty"`

	TransferredClasses []TransferredClassesInitParameters `json:"transferredClasses,omitempty" tf:"transferred_classes,omitempty"`
}

type StepsObservation struct {

	// A list of classes to delete Durable Object namespaces from.
	DeletedClasses []*string `json:"deletedClasses,omitempty" tf:"deleted_classes,omitempty"`

	// A list of classes to create Durable Object namespaces from.
	NewClasses []*string `json:"newClasses,omitempty" tf:"new_classes,omitempty"`

	// A list of classes to create Durable Object namespaces with SQLite from.
	NewSqliteClasses []*string `json:"newSqliteClasses,omitempty" tf:"new_sqlite_classes,omitempty"`

	RenamedClasses []StepsRenamedClassesObservation `json:"renamedClasses,omitempty" tf:"renamed_classes,omitempty"`

	TransferredClasses []TransferredClassesObservation `json:"transferredClasses,omitempty" tf:"transferred_classes,omitempty"`
}

type StepsParameters struct {

	// A list of classes to delete Durable Object namespaces from.
	// +kubebuilder:validation:Optional
	DeletedClasses []*string `json:"deletedClasses,omitempty" tf:"deleted_classes,omitempty"`

	// A list of classes to create Durable Object namespaces from.
	// +kubebuilder:validation:Optional
	NewClasses []*string `json:"newClasses,omitempty" tf:"new_classes,omitempty"`

	// A list of classes to create Durable Object namespaces with SQLite from.
	// +kubebuilder:validation:Optional
	NewSqliteClasses []*string `json:"newSqliteClasses,omitempty" tf:"new_sqlite_classes,omitempty"`

	// +kubebuilder:validation:Optional
	RenamedClasses []StepsRenamedClassesParameters `json:"renamedClasses,omitempty" tf:"renamed_classes,omitempty"`

	// +kubebuilder:validation:Optional
	TransferredClasses []TransferredClassesParameters `json:"transferredClasses,omitempty" tf:"transferred_classes,omitempty"`
}

type StepsRenamedClassesInitParameters struct {
	From *string `json:"from,omitempty" tf:"from,omitempty"`

	To *string `json:"to,omitempty" tf:"to,omitempty"`
}

type StepsRenamedClassesObservation struct {
	From *string `json:"from,omitempty" tf:"from,omitempty"`

	To *string `json:"to,omitempty" tf:"to,omitempty"`
}

type StepsRenamedClassesParameters struct {

	// +kubebuilder:validation:Optional
	From *string `json:"from,omitempty" tf:"from,omitempty"`

	// +kubebuilder:validation:Optional
	To *string `json:"to,omitempty" tf:"to,omitempty"`
}

type TailConsumersInitParameters struct {

	// Optional environment if the Worker utilizes one.
	Environment *string `json:"environment,omitempty" tf:"environment,omitempty"`

	// Optional dispatch namespace the script belongs to.
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// Name of Worker that is to be the consumer.
	Service *string `json:"service,omitempty" tf:"service,omitempty"`
}

type TailConsumersObservation struct {

	// Optional environment if the Worker utilizes one.
	Environment *string `json:"environment,omitempty" tf:"environment,omitempty"`

	// Optional dispatch namespace the script belongs to.
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// Name of Worker that is to be the consumer.
	Service *string `json:"service,omitempty" tf:"service,omitempty"`
}

type TailConsumersParameters struct {

	// Optional environment if the Worker utilizes one.
	// +kubebuilder:validation:Optional
	Environment *string `json:"environment,omitempty" tf:"environment,omitempty"`

	// Optional dispatch namespace the script belongs to.
	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// Name of Worker that is to be the consumer.
	// +kubebuilder:validation:Optional
	Service *string `json:"service" tf:"service,omitempty"`
}

type TransferredClassesInitParameters struct {
	From *string `json:"from,omitempty" tf:"from,omitempty"`

	FromScript *string `json:"fromScript,omitempty" tf:"from_script,omitempty"`

	To *string `json:"to,omitempty" tf:"to,omitempty"`
}

type TransferredClassesObservation struct {
	From *string `json:"from,omitempty" tf:"from,omitempty"`

	FromScript *string `json:"fromScript,omitempty" tf:"from_script,omitempty"`

	To *string `json:"to,omitempty" tf:"to,omitempty"`
}

type TransferredClassesParameters struct {

	// +kubebuilder:validation:Optional
	From *string `json:"from,omitempty" tf:"from,omitempty"`

	// +kubebuilder:validation:Optional
	FromScript *string `json:"fromScript,omitempty" tf:"from_script,omitempty"`

	// +kubebuilder:validation:Optional
	To *string `json:"to,omitempty" tf:"to,omitempty"`
}

type WorkerInitParameters struct {

	// Environment of the outbound worker.
	Environment *string `json:"environment,omitempty" tf:"environment,omitempty"`

	// Name of the outbound worker.
	Service *string `json:"service,omitempty" tf:"service,omitempty"`
}

type WorkerObservation struct {

	// Environment of the outbound worker.
	Environment *string `json:"environment,omitempty" tf:"environment,omitempty"`

	// Name of the outbound worker.
	Service *string `json:"service,omitempty" tf:"service,omitempty"`
}

type WorkerParameters struct {

	// Environment of the outbound worker.
	// +kubebuilder:validation:Optional
	Environment *string `json:"environment,omitempty" tf:"environment,omitempty"`

	// Name of the outbound worker.
	// +kubebuilder:validation:Optional
	Service *string `json:"service,omitempty" tf:"service,omitempty"`
}

// ScriptSpec defines the desired state of Script
type ScriptSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ScriptParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider ScriptInitParameters `json:"initProvider,omitempty"`
}

// ScriptStatus defines the observed state of Script.
type ScriptStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ScriptObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Script is the Schema for the Scripts API. <no value>
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,cloudflare}
type Script struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.accountId) || (has(self.initProvider) && has(self.initProvider.accountId))",message="spec.forProvider.accountId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.scriptName) || (has(self.initProvider) && has(self.initProvider.scriptName))",message="spec.forProvider.scriptName is a required parameter"
	Spec   ScriptSpec   `json:"spec"`
	Status ScriptStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ScriptList contains a list of Scripts
type ScriptList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Script `json:"items"`
}

// Repository type metadata.
var (
	Script_Kind             = "Script"
	Script_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Script_Kind}.String()
	Script_KindAPIVersion   = Script_Kind + "." + CRDGroupVersion.String()
	Script_GroupVersionKind = CRDGroupVersion.WithKind(Script_Kind)
)

func init() {
	SchemeBuilder.Register(&Script{}, &ScriptList{})
}
